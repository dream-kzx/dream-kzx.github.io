[{"title":"C++包管理工具vcpkg的使用","url":"/2020/06/08/C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7vcpkg%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\n前言&emsp;&emsp;最近在使用c++时，发现编译第三方库真的烦，同时还要在vs的设置中引入包含目录、库目录，操作起来十分繁琐。之后github上找到了vcpkg这个微软开发的包管理工具，用起来挺顺手的，就是下载包的时候，由于包服务器在外网，很多时候会安装失败，这是一个苦恼的问题。最近，在一片博客看到有大佬搭建国内个人镜像，没有梯子的，可以去了解一下。\n安装&emsp;&emsp;安装很简单，可以参考github提供的README.md。\n\n首先第一步从vcpkg仓库把代码clone下来：&gt; git clone git@github.com:microsoft&#x2F;vcpkg.git&gt; cd vcpkg\n然后第二步，使用命令编译vcpkg&gt; .\\bootstrap-vcpkg.bat   &#x2F;&#x2F;windows下&gt; .&#x2F;bootstrap-vcpkg.sh    &#x2F;&#x2F;Linux下\n第三步，为了方便操作，可以将目录下生成的vcpkg可执行文件，加入到系统的环境变量\n第四步，为全局配置vcpkg&gt; vcpkg integrate install\n&emsp;&emsp;在这一步之后，在windows下，VS中，可以直接在头部引入安装的库使用，不需要其他包含库目录等操作，十分方便。&emsp;&emsp;对于不使用vs的情况，vcpkg可以在cmake中使用，通过编译参数-DCMAKE_TOOLCHAIN_FILE = [vcpkg root]\\scripts\\buildsystems\\vcpkg.cmake，进行配置，实例如下：cmake_minimum_required (VERSION 3.8)project(ManagerServer)set(CMAKE_CXX_STANDARD 14)#G:/c++ Depende/vcpkg, 是我的vcpkg的根目录，在使用的时候需要更换为自己的set(VCPKG_ROOT &quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot; CACHE PATH &quot;&quot;)set(CMAKE_TOOLCHAIN_FILE $&#123;VCPKG_ROOT&#125;)#这个是查找sqlite3库的操作， 安装sqlite3的操作，请看文章的下一部分find_package(sqlite3 CONFIG REQUIRED)aux_source_directory(. sourceList)# 将源代码添加到此项目的可执行文件。add_executable (ManagerServer $&#123;sourceList&#125;)#进行sqlite3库的链接target_link_libraries(ManagerServer PRIVATE sqlite3)\n\n使用&emsp;&emsp;接下来是关于vcpkg的使用，本文以官方文档描述的安装和使用sqlite3的例子来介绍。\n\n通过search参数来查找提供的第三方包\n&gt; vcpkg search sqlite3dlib[sqlite3]                         sqlite3 support for dlibsoci[sqlite3]                         Build sqlite3 backendsqlite3              3.32.0-0         SQLite is a software library that implements a self-contained, serverless, zer...sqlite3[tool]                         sqlite3 executablesqlitecpp            3.0.0            SQLiteC++ (SQLiteCpp) is a smart and easy to use C++ SQLite3 wrapper.sqlpp11-connector... 0.29-2           A C++ wrapper for sqlite3 meant to be used in combination with sqlpp11.\n通过install命令来安装包&emsp;&emsp;在安装包之前，需要查看本机的VS环境是否安装的English的语言包，否则，会出现警告和报错的问题。接下来，是使用install安装第三方包，示例的环境是windows10。\n&gt; vcpkg install sqlite3Computing installation plan...The following packages will be built and installed:    sqlite3[core]:x86-windowsStarting package 1/1: sqlite3:x86-windowsBuilding package sqlite3[core]:x86-windows...-- Using cached G:/C++ Depende/vcpkg/downloads/sqlite-amalgamation-3320000.zip-- Using source at G:/C++ Depende/vcpkg/buildtrees/sqlite3/src/3320000-f17e2f22e8-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Performing post-build validation-- Performing post-build validation doneBuilding package sqlite3[core]:x86-windows... doneInstalling package sqlite3[core]:x86-windows...Installing package sqlite3[core]:x86-windows... doneElapsed time for package sqlite3:x86-windows: 11.25 sTotal elapsed time: 11.25 sThe package sqlite3:x86-windows provides CMake targets:    find_package(sqlite3 CONFIG REQUIRED)    target_link_libraries(main PRIVATE sqlite3)//在windows下命令默认编译的是x86的包，可以通过&quot;:&quot;指定，比如：&gt; vcpkg install sqlite3:x64-windows\n&emsp;&emsp;在完成安装后，可以看出命令行输出了，在camke中的使用语句，将其写入CMakeLists.txt就可以了，特别要注意target_link_libraries(main PRIVATE sqlite3)add_executable()后面。\n\n利用list参数，查看已经编译安装的包\n&gt; vcpkg listsqlite3:x64-windows                                3.32.0-0         SQLite is a software library that implements a s...sqlite3:x86-windows                                3.32.0-0         SQLite is a software library that implements a s...\n利用remove参数，卸载已经编译安装的包\n&gt; vcpkg remove [package_name]\n\n使用实例\nmain.cpp文件// main.cpp#include &lt;errno.h&gt;#include &lt;sqlite3.h&gt;#include &lt;stdio.h&gt;int main() &#123;  sqlite3 *pdb = nullptr;  int result;  result = sqlite3_open(&quot;test.db&quot;, &amp;pdb);  if (result != SQLITE_OK) &#123;    perror(&quot;sqlite_open error!&quot;);    return -1;  &#125;  sqlite3_stmt *pStmt;  const char *sql =      &quot;create table Student(&quot;      &quot;t_id, integer primary key, &quot;      &quot;t_name varchar(15), t_age integer)&quot;;  char *errMsg = NULL;  result = sqlite3_exec(pdb, sql, NULL, NULL, &amp;errMsg);  if (result != SQLITE_OK) &#123;    printf(&quot;create table student failed!\\n&quot;);    printf(&quot;error conde %d \\t error message:%s\\n&quot;, result, errMsg);  &#125;  printf(&quot;create table success!\\n&quot;);  return 0;&#125;\nCMakeLists.txt文件#CMakeLists.txtcmake_minimum_required (VERSION 3.8)project(ManagerServer)set(CMAKE_CXX_STANDARD 14)set(VCPKG_ROOT &quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot; CACHE PATH &quot;&quot;)set(CMAKE_TOOLCHAIN_FILE $&#123;VCPKG_ROOT&#125;)find_package(sqlite3 CONFIG REQUIRED)aux_source_directory(. sourceList)# 将源代码添加到此项目的可执行文件。add_executable (ManagerServer $&#123;sourceList&#125;)target_link_libraries(ManagerServer PRIVATE sqlite3)\n\n参考文章\nvcpkg国内镜像使用方法\n\n","categories":["C++"],"tags":["C++","包管理工具"]},{"title":"Linux安装Go语言","url":"/2020/11/14/Linux%E5%AE%89%E8%A3%85Go%E8%AF%AD%E8%A8%80/","content":"本章介绍在linux下安装go语言，以及一些环境变量的配置，本文的运行环境为ubuntu系统\n\n说明在ubuntu中，可以直接使用apt-get命令来安装golang，但是由于apt源中的golang通常不是最新的，所以本章使用下载的二进制包进行安装golang。\n获取golang进入Golang官网，点击Download Go，进入下载界面，选择Linux版本tar.gz文件，右键选择复制链接地址。\n进入ubuntu的bash界面，输入命令，下载文件\nwget https://golang.org/dl/go1.15.5.linux-amd64.tar.gz\n第二步解压缩包\ntar -zxvf go1.15.5.linux-amd64.tar.gz\n\n设置环境变量对于解压后的压缩包，设置相应的环境变量之后即可运行Golang，环境变量设置如下.\n#进入根目录&gt; cd ~/#编辑.bashrc文件&gt; sudo vim .bashrc#在文件最下面，设置Golang相关环境变量export GOPROXY=https://goproxy.cn,directexport GO111MODULE=onexport GOROOT= &quot;解压压缩包路径&quot;export GOPATH= &quot;自定义路径，用于保存一些第三方包&quot;PATH=$GOROOT/bin:$GOPATH/bin:$PATH#保存.bashrc文件，执行如下命令即可source ./bashrc#测试是否配置成功&gt; go versiongo version go1.15.5 linux/amd64\n\n环境变量的描述\nGOPROXY：由于国内的网络访问外网较慢，所以在下载第三方包，会出现超时的情况，所以国内大佬们搭建了库的镜像，该配置就是为了配置代理。\nGO111MODULE：启用go module，go module是在go1.11版本加入的，一种包管理的工具\nGOROOT：这个就不解释了\nGOPATH：第三方包下载保存的路径，包括了go module管理包的路径\n\n解决一些小问题在需要使用sudo命令进行编译运行golang时，已设置的环境变量会被置为默认，比如gopath路径被改变，程序所需要依赖的包在编译时就需要重新下载。可以通过如下配置进行设置，在sudo的情况下环境变量不被清空。\n#进入如下文件&gt; sudo visudo /etc/sudoers#添加如下命令即可Defaults !env_reset#同时需要注释掉Defaults secure_path=&quot;****&quot;\n\n参考文章:\n","categories":["Golang"]},{"title":"Golang基本输入输出(io包接口)","url":"/2020/10/25/Golang%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA(io%E5%8C%85%E6%8E%A5%E5%8F%A3)/","content":"&emsp;&emsp;在本章的所有的io接口时，有一个特点，在读取或写入的n=len(p)时，返回的接口err=nil或者err=EOF；当n&lt;len(p)时，需要返回err解释原因。\n\n\n\n1. Reader接口&emsp;&emsp;在官方io包中定义了如下接口，只要实现了Read方法，就是将其传递为io.Reader类型的参数\ntype Reader interface &#123;    Read(p []byte)(n int, err error)&#125;\n2. Writer接口&emsp;&emsp;在官方的io包中定义里如下接口，只要实现了Write方法，也就是实现了Writer接口\ntype Writer interface&#123;    Write(p []byte)(n int, err error)&#125;\n3. 实现Reader和Writer接口的类型\nos.File同时实现了io.Reader和io.Writer接口\nstrings.Reader实现了io.Reader接口\nbufio.Reader/Writer分别实现了io.Reader和io.Writer接口\nbytes.Buffer同时实现了io.Reader和io.Writer接口\nbytes.Reader实现了io.Reader接口\ncompress/gzip.StreamReader/StreamWriter分别实现了io.Reader和io.Writer接口\nencoding/csv.Reader/Writer分别实现了io.Reader和io.Writer接口\nnet/conn分别实现了io.Reader和io.Writer接口(Conn接口定义了Read/Write)4. ReaderAt接口&emsp;&emsp;该接口是从源输入的偏移量off处读取len(p)个字节到p中。type ReaderAt struct &#123;    ReadAt(p []byte, off int64)(n int, err error)&#125;\n5. WriterAt接口&emsp;&emsp;该接口是在源输出的偏移量off处写入len(p)个字节。type WriterAt struct &#123;    WriteAt(p []byte, off int64)(n int, err error)&#125;\n6. ReaderFrom接口&emsp;&emsp;ReadFrom从r中读取数据，直到EOF或发生错误。type ReaderFrom struct &#123;    ReadFrom(r Reader)(n int64, err error)&#125;\n使用示例file, err := os.Open(&quot;writerAt.txt&quot;)if err != nil&#123;    painc(err)&#125;defer file.Close()writer := bufio.NewWriter(os.Stdout)writer.ReadFrom(file)writer.Flush()\n7. WriterTo接口&emsp;emsp;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。type WriterTo struct&#123;    WriteTo(w Writer)(n int, err error)&#125;\n8. Seeker接口&emsp;&emsp;Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。const(    SeekStart = 0    SeekCurrent = 1    SeekEnd = 2)type Seeker struct&#123;    Seek(offset int64, whence int)(ret int64, err error)&#125;\n9. Closer接口接口定义如下：type Closer interface&#123;    Close() error&#125;\n\n10. ByteReader和ByteWriter接口&emsp;&emsp;这个两个接口用于读/写一个字节\ntype ByteReader interface&#123;    ReadByte()(c byte, err error)&#125;type ByteWriter interface&#123;    WriteByte(c byte) error&#125;\n在标准库中，有如下类型实现了 io.ByteReader 或 io.ByteWriter:bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriterbytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriterbytes.Reader 实现了 io.ByteReaderstrings.Reader 实现了 io.ByteReader\n11. ByteScanner、RuneReader和RuneScanner接口&emsp;&emsp;UnreadByte 方法的意思是：将上一次 ReadByte 的字节还原，使得再次调用 ReadByte 返回的结果和上一次调用相同，也就是说，UnreadByte 是重置上一次的 ReadByte。注意，UnreadByte 调用之前必须调用了 ReadByte，且不能连续调用 UnreadByte。\ntype ByteScanner interface &#123;    ByteReader    UnreadByte() error&#125;//RuneReader和ByteReader类似type RuneReader interface &#123;    ReadRune()(r rune, size int, err error)&#125;//RuneScanner和ByteScanner类似type RuneScanner interface &#123;    RuneReader    UnreadRune() error&#125;\n12. SectionReader接口&emsp;&emsp;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。\ntype SectionReader struct &#123;    r       ReaderAt    base    int64  //NewSectionReader会将base设置为off    off     int64  //从r中off偏移处开始读取数据    limit   int64  //limit-off = SectionReader流的长度&#125;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader &#123;&#125;\n\n\nLimitedReader接口&emsp;&emsp;从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。也就是说，最多只能返回 N 字节数据。type LimitedReader struct &#123;    R Reader //underlying reader,最终的读取通过R.Read完成    N int64 //max bytes remaining&#125;\n&emsp;&emsp;使用示例content := &quot;This is LimitReader Example&quot;reader := strings.NewReader(content)limitReader := &amp;io.LimitedReader&#123;R:reader, N:8&#125;for limitReader.N &gt; 0&#123;    tmp := make([]byte, 2)    limitReader.Read(tmp)    fmt.Printf(&quot;%s&quot;, tmp)&#125;//输出： This Is//从结果看一看出最多只能读取N个字符\n\n14. PipeReader和PipeWriter接口&emsp;&emsp;关于 PipeReader.Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 error（即调用 CloseWithError 关闭），该Read返回的 err 就是写入端传递的error；否则 err 为 EOF。&emsp;&emsp;关于 PipeWriter.Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时带有 error（即调用 CloseWithError 关闭），该Write返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。\ntype PipeReader struct &#123;    p *pipe&#125;type PipeWriter struct&#123;    p *pipe&#125;\n&emsp;&emsp;使用示例如下\nfunc main() &#123;    pipeReader, pipeWriter := io.Pipe()    go PipeWrite(pipeWriter)    go PipeRead(pipeReader)    time.Sleep(30 * time.Second)&#125;func PipeWrite(writer *io.PipeWriter)&#123;    data := []byte(&quot;hello world!&quot;)    for i := 0; i &lt; 3; i++&#123;        n, err := writer.Write(data)        if err != nil&#123;            fmt.Println(err)            return        &#125;        fmt.Printf(&quot;写入字节%d\\n&quot;, n)    &#125;    writer.CloseWithError(errors.New(&quot;写入段已经关闭！&quot;))&#125;func PipeRead(reader *io.PipeReader)&#123;    buf := make([]byte, 128)    for&#123;        fmt.Println(&quot;接口开始测试....&quot;)        time.Sleep(5*time.Second)        n, err := reader.Read(buf)        if err != nil&#123;            fmt.Println(err)            return        &#125;        fmt.Printf(&quot;收到%d个字节，数据为：%s\\n&quot;, n, buf)    &#125;&#125;\n\n15. Copy和CopyN函数&emsp;&emsp;Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。\nfunc Copy(dst Writer, src Reader)(written int64, err error)&#123;&#125;\n&emsp;&emsp;CopyN 将 n 个字节(或到一个error)从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当err == nil时,written == n 。&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。\nfunc CopyN(dst Writer, src Reader, n int64)(written int64, err error)&#123;&#125;\n16. ReadAtLeast和ReadFull函数&emsp;&emsp;ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个EOF 发生在读取了少于min个字节之后，ReadAtLeast就会返回ErrUnexpectedEOF。若 min 大于 buf 的长度，ReadAtLeast 就会返回ErrShortBuffer。对于返回值，当且仅当 err == nil 时，才有 n &gt;= min。\nfunc ReadAtLeast(r Reader, buf []byte, min int)(n int, err error)&#123;&#125;\n&emsp;&emsp;ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF。对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。\nfunc ReadFull(r Reader, buf []byte)(n int, err error)\n\n17. WriteString函数&emsp;&emsp;WriteString 将s的内容写入w中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。\nfunc WriteString(w writer, s string)(n int, err error)\n\n18. MultiReader和MultiWriter函数type multiReader struct &#123;    readers []Reader&#125;type multiWriter struct &#123;    writers []Writer&#125;func MultiReader(readers ...Reader) Readerfunc MultiWriter(writers ...Writer) Writer\n使用示例如下：\nreaders := []io.Reader&#123;    strings.NewReader(&quot;from strings reader&quot;),    bytes.NewBufferString(&quot;from bytes buffer&quot;),&#125;reader := io.MultiReader(readers...)data := make([]byte, 0, 128)buf := make([]byte, 10)for n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123;    if err != nil&#123;        panic(err)    &#125;    data = append(data,buf[:n]...)&#125;fmt.Printf(&quot;%s\\n&quot;, data)//输出//from strings readerfrom bytes buffer\n\nfile, err := os.Create(&quot;tmp.txt&quot;)if err != nil &#123;    panic(err)&#125;defer file.Close()writers := []io.Writer&#123;    file,    os.Stdout,&#125;writer := io.MultiWriter(writers...)writer.Write([]byte(&quot;Hello World!&quot;))//输出：控制台和文件同时输出Hello World!\n\n参考文章:《Go语言标准库》\n","categories":["Golang"]},{"title":"go-kit/etcdv3库学习","url":"/2020/12/06/go-kit-etcdv3%E5%BA%93%E5%AD%A6%E4%B9%A0/","content":"&emsp;&emsp;本章介绍使用go-kit的工具包etcdv3进行对etcd做服务注册和发现操作\n\n预备知识etcd的key-value存储和查找方式&emsp;&emsp;etcd是使用key-value的形式进行存储的，与consul不同的是，etcd的查找是通过前缀进行查找的。举个例子，服务名为hellworld的服务部署了3个实例在不同的服务器上：&emsp;&emsp;”http://192.168.10.111:8888&quot;&emsp;&emsp;”http://192.168.10.112:8888&quot;&emsp;&emsp;”http://192.168.10.113:8888&quot;那么在etcd服务器中存储的值一般的存储方式为：key1 = “/service/helloworld/192.168.10.111:8888” value1 = “http://192.168.10.111:8888&quot;key2 = “/service/helloworld/192.168.10.112:8888” value2 = “http://192.168.10.112:8888&quot;key3 = “/service/helloworld/192.168.10.113:8888” value3 = “http://192.168.10.113:8888&quot;&emsp;&emsp;那么在服务发现时，就通过查找前缀为”/service/helloworld/“的所有的key-value，etcd就会返回前缀为”/service/helloworld/“所有的值。\n服务注册&emsp;&emsp;go-kit提供了对etcd进行服务注册的封装的函数\ntype ClientOptions struct &#123;\tCert          string    //用于SSL\tKey           string    //用于SSL\tCACert        string    //用于SSL\tDialTimeout   time.Duration     //建立连接失败的超时时间\tDialKeepAlive time.Duration     //存活检测时间\tUsername      string            //etcd的用户名，未在etcd中设置，则不需要\tPassword      string            //etcd的密码，未在etcd中设置，则不需要&#125;//etcd创建客户端接口，machines为etcd的地址func NewClient(ctx context.Context, machines []string, options ClientOptions) (Client, error)type Service struct &#123;\tKey   string        //存储在etcd的key\tValue string        //存储在etcd的value\tTTL   *TTLOption    //心跳检测时间&#125;//NewRegistrarfunc NewRegistrar(client Client, service Service, logger log.Logger) *Registrar\n\n使用etcdv3进行服务注册，etcdv3的接口中封装了对etcd存活检测的操作\nfunc main()&#123;    etcdHost := &quot;127.0.0.1&quot;    etcdPort := 2379    serviceHost := &quot;127.0.0.1&quot;    servicePort := 8888    serviceName := &quot;service/hellworld&quot;    ctx := context.Background()    clientOption := etcdv3.ClientOption&#123;        DialTimeout: 3 * time.Second,        DialKeepAlive: 3* time.Second,    &#125;    addr := etcdHost+&quot;:&quot;+strconv.Itoa(etcdPort)    //创建etcd客户端    client, err := etcdv3.NewClient(ctx, []string&#123;addr&#125;, clientOption)    if err != nil&#123;        log.Println(err)        return    &#125;    addr := serviceHost + &quot;:&quot; + strconv.Itoa(servicePort)    key := string.TrimRight(serviceName, &quot;/&quot;) + &quot;/&quot; + addr    value := &quot;http://&quot; + addr    //创建注册器    registrar := etcdv3.NewRegistrar(client, etcdv3.Service&#123;Key: key, Value: value&#125;, kitlog.NewNopLogger())    //服务注册    registrar.Registrar()    errChan := make(chan error)    go func()&#123;        errChan &lt;- http.ListenAndServe(:+strconv.Itoa(servicePort, nil))    &#125;()    go func()&#123;        c := make(chan os.Signal, 1)        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)        errChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c)    &#125;()    err := &lt;-errChan    registrar.DeRegister()&#125;\n\n服务发现&emsp;&emsp;etcdv3中同样封装了服务发现的接口，同时接口提供了服务变更时通知的接口\nfunc main()&#123;    etcdHost := &quot;127.0.0.1&quot;    etcdPort := 2379    prefix := &quot;/service/helloworld/&quot;    ctx := context.Background()    clientOption := etcdv3.ClientOption&#123;        DialTimeout: 3 * time.Second,        DialKeepAlive: 3* time.Second,    &#125;    addr := etcdHost+&quot;:&quot;+strconv.Itoa(etcdPort)    //创建etcd客户端    client, err := etcdv3.NewClient(ctx, []string&#123;addr&#125;, clientOption)    if err != nil&#123;        log.Println(err)        return    &#125;    instancer, err := etcdv3.NewInstancer(client, prefix, kitlog.NewNopLogger())    if err != nil&#123;        log.Println(err)        return    &#125;    ch := make(chan sd.Event)    //将chan注册到instancer中，当服务发生变化时，会将新的数据更新到chan    go func() &#123;        instancer.Register(ch)    &#125;    //获取更新的值    go func() &#123;        for event := range ch&#123;            if event.Err != nil&#123;                log.Println(event.Err)            &#125;            fmt.Println(&quot;service url is: &quot;, event.Instances)        &#125;    &#125;()    go func()&#123;        c := make(chan os.Signal, 1)        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)        errChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c)    &#125;()    err := &lt;-errChan    instancer.DeRegister(ch)&#125;\n\n自己的接口封装&emsp;&emsp;为了简化以后的使用，自己封装了一个结构体，不足之处请指出\npackage commonimport (    &quot;context&quot;    &quot;errors&quot;    &quot;github.com/go-kit/kit/sd&quot;    &quot;log&quot;    &quot;strconv&quot;    &quot;strings&quot;    &quot;sync&quot;    &quot;time&quot;    kitlog &quot;github.com/go-kit/kit/log&quot;    &quot;github.com/go-kit/kit/sd/etcdv3&quot;)type EtcdV3DiscoverClient struct &#123;    client    etcdv3.Client    registrar *etcdv3.Registrar    instanceMutex sync.Mutex    instances     map[string]*etcdv3.Instancer    serviceMutex sync.Mutex    serviceUrls  map[string][]string&#125;func NewEctdV3DiscoverClient(ectdHost string, ectdPort int) *EtcdV3DiscoverClient &#123;    ctx := context.Background()    clientOption := etcdv3.ClientOptions&#123;        DialTimeout:   3 * time.Second,        DialKeepAlive: 3 * time.Second,    &#125;    addr := ectdHost + &quot;:&quot; + strconv.Itoa(ectdPort)    client, err := etcdv3.NewClient(ctx, []string&#123;addr&#125;, clientOption)    if err != nil &#123;        log.Println(err)        return nil    &#125;    return &amp;EtcdV3DiscoverClient&#123;        client: client,        instances: make(map[string]*etcdv3.Instancer),        serviceUrls: make(map[string][]string),    &#125;&#125;func (cli *EtcdV3DiscoverClient) Register(serviceName string, serviceHost string, servicePort int) &#123;    addr := serviceHost + &quot;:&quot; + strconv.Itoa(servicePort)    key := strings.TrimRight(serviceName, &quot;/&quot;) + &quot;/&quot; + addr    value := &quot;http://&quot; + addr    cli.registrar = etcdv3.NewRegistrar(cli.client, etcdv3.Service&#123;Key: key, Value: value&#125;, kitlog.NewNopLogger())    cli.registrar.Register()&#125;func (cli *EtcdV3DiscoverClient) DeRegister() &#123;    cli.registrar.Deregister()&#125;func (cli *EtcdV3DiscoverClient) DiscoveryServices(serviceName string) ([]string, error) &#123;    var err error    prefix := strings.TrimRight(serviceName, &quot;/&quot;) + &quot;/&quot;    cli.instanceMutex.Lock()    instancer, ok := cli.instances[serviceName]    cli.instanceMutex.Unlock()    if !ok &#123;        instancer, err = etcdv3.NewInstancer(cli.client, prefix, kitlog.NewNopLogger())        if err != nil &#123;            return nil, err        &#125;        cli.serviceMutex.Lock()        cli.instances[serviceName] = instancer        cli.serviceMutex.Unlock()        cli.watch(instancer, serviceName)        return cli.client.GetEntries(prefix)    &#125;    cli.serviceMutex.Lock()    serviceUrl, ok := cli.serviceUrls[serviceName]    cli.serviceMutex.Unlock()    if !ok &#123;        return nil, errors.New(&quot;no service url&quot;)    &#125;    return serviceUrl, nil&#125;func (cli *EtcdV3DiscoverClient) watch(instancer *etcdv3.Instancer , serviceName string) &#123;    ch := make(chan sd.Event)    go func()&#123;        instancer.Register(ch)    &#125;()    go func() &#123;        for event := range ch &#123;            if event.Err != nil &#123;            &#125;            cli.serviceMutex.Lock()            cli.serviceUrls[serviceName] = event.Instances            log.Println(time.Now())            cli.serviceMutex.Unlock()        &#125;        instancer.Deregister(ch)        cli.instanceMutex.Lock()        delete(cli.instances, serviceName)        cli.instanceMutex.Unlock()    &#125;()&#125;\n\n\n参考文章:\n","categories":["Golang"]},{"title":"go进阶训练营第1周","url":"/2021/02/25/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC1%E5%91%A8/","content":"首页显示摘要内容（替换成自己的）\n\n参考文章:参考链接\n"},{"title":"go-kit中使用consul服务注册与发现、健康检测","url":"/2021/01/03/go-kit%E4%B8%AD%E4%BD%BF%E7%94%A8consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B/","content":"&emsp;&emsp;本章介绍在go-kit中进行使用服务发现和注册，以及健康检测\n\n首先使用kit提供的库，定义对consul的访问&emsp;&emsp;首先定义服务发现的客户端接口，接口需要提供3个方法，服务注册、服务注销以及服务发现。\npackage discoveryimport &quot;log&quot;type DiscoverClient interface&#123;    Register(serviceName, instanceId, healthCheckUrl string,        instanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool    DeRegister(instanceId string, logger *log.Logger) bool    DiscoveryServices(serviceName string, logger *log.Logger) []interface&#123;&#125;&#125;\n\n&emsp;&emsp;然后定义对接口的实现，在此处使用go-kit封装的库对接口进行实现，同时在服务发现部分通过map对服务进行缓存，在服务发生变化时，通过获取consul的通知进行更新map\npackage discoveryimport (\t&quot;github.com/go-kit/kit/sd/consul&quot;\t&quot;github.com/hashicorp/consul/api&quot;\t&quot;github.com/hashicorp/consul/api/watch&quot;\t&quot;log&quot;\t&quot;strconv&quot;\t&quot;sync&quot;)type KitDiscoverClient struct &#123;\tconsulHost  string          //consul的地址\tconsulPort  int             //consul的端口\tclient      consul.Client   //kit封装consul的客户端\tconfig      *api.Config     //kit封装的consul配置\tmutex       sync.Mutex\tinstanceMap sync.Map&#125;func NewKitDiscoverClient(consulHost string, consulPort int) (DiscoverClient, error) &#123;\tconsulConfig := api.DefaultConfig()\tconsulConfig.Address = consulHost + &quot;:&quot; + strconv.Itoa(consulPort)\tapiClient, err := api.NewClient(consulConfig)\tif err != nil &#123;\t\treturn nil, err\t&#125;\tclient := consul.NewClient(apiClient)\treturn &amp;KitDiscoverClient&#123;\t\tconsulHost: consulHost,\t\tconsulPort: consulPort,\t\tclient:     client,\t\tconfig:     consulConfig,\t&#125;, nil&#125;func (consulClient *KitDiscoverClient) Register(serviceName, instanceId, healthCheckUrl string,\tinstanceHost string, instancePort int, meta map[string]string, logger *log.Logger) bool &#123;\tserviceRegistration := &amp;api.AgentServiceRegistration&#123;\t\tID:      instanceId,\t\tName:    serviceName,\t\tAddress: instanceHost,\t\tPort:    instancePort,\t\tMeta:    meta,\t\tCheck: &amp;api.AgentServiceCheck&#123;\t\t\tDeregisterCriticalServiceAfter: &quot;30s&quot;,\t\t\tHTTP:                           &quot;http://&quot; + instanceHost + &quot;:&quot; + strconv.Itoa(instancePort) + healthCheckUrl,\t\t\tInterval:                       &quot;15s&quot;,\t\t&#125;,\t&#125;\terr := consulClient.client.Register(serviceRegistration)\tif err != nil &#123;\t\tlog.Println(&quot;Register Service Error!&quot;)\t\treturn false\t&#125;\tlog.Println(&quot;Register Service Success!&quot;)\treturn true&#125;func (consulClient *KitDiscoverClient) DeRegister(instanceId string, logger *log.Logger) bool &#123;\tserviceRegistration := &amp;api.AgentServiceRegistration&#123;\t\tID: instanceId,\t&#125;\terr := consulClient.client.Deregister(serviceRegistration)\tif err != nil &#123;\t\tlogger.Println(&quot;Deregister Service Error!&quot;)\t\treturn false\t&#125;\tlog.Println(&quot;Deregister Service Success!&quot;)\treturn true&#125;func (consulClient *KitDiscoverClient) DiscoveryServices(serviceName string, logger *log.Logger) []interface&#123;&#125; &#123;    //判断服务是否已缓存\tinstanceList, ok := consulClient.instanceMap.Load(serviceName)\tif ok &#123;\t\treturn instanceList.([]interface&#123;&#125;)\t&#125;    consulClient.mutex.Lock()    defer consulClient.mutex.Unlock()    //加锁后在判断一次，服务是否已缓存\tinstanceList, ok = consulClient.instanceMap.Load(serviceName)\tif ok &#123;\t\treturn instanceList.([]interface&#123;&#125;)\t&#125;    //响应服务变更通知，更新服务map\tgo func() &#123;\t\tparams := make(map[string]interface&#123;&#125;)\t\tparams[&quot;type&quot;] = &quot;service&quot;\t\tparams[&quot;service&quot;] = serviceName\t\tplan, _ := watch.Parse(params)\t\tplan.Handler = func(u uint64, i interface&#123;&#125;) &#123;\t\t\tif i == nil &#123;\t\t\t\treturn\t\t\t&#125;\t\t\tv, ok := i.([]*api.ServiceEntry)\t\t\tif !ok &#123;\t\t\t\treturn\t\t\t&#125;\t\t\tif len(v) == 0 &#123;\t\t\t\tconsulClient.instanceMap.Store(serviceName, []interface&#123;&#125;&#123;&#125;)\t\t\t&#125;\t\t\tvar healthServices []interface&#123;&#125;\t\t\tfor _, service := range v &#123;\t\t\t\tif service.Checks.AggregatedStatus() == api.HealthPassing &#123;\t\t\t\t\thealthServices = append(healthServices, service)\t\t\t\t&#125;\t\t\t&#125;\t\t\tconsulClient.instanceMap.Store(serviceName, healthServices)\t\t&#125;\t\tdefer plan.Stop()\t\tplan.Run(consulClient.config.Address)\t&#125;()    //调用go-kit库向consul获取服务\tentries, _, err := consulClient.client.Service(serviceName, &quot;&quot;, false, nil)\tif err != nil &#123;\t\tconsulClient.instanceMap.Store(serviceName, []interface&#123;&#125;&#123;&#125;)\t\tlogger.Println(&quot;Discover Service Error&quot;)\t\treturn nil\t&#125;\tinstances := make([]interface&#123;&#125;, 0, len(entries))\tfor _, instance := range entries &#123;\t\tinstances = append(instances, instance)\t&#125;\tconsulClient.instanceMap.Store(serviceName, instances)\treturn instances&#125;\n\n定义服务&emsp;&emsp;定义服务，本文实例定义两个服务：SayHello和HealthCheck。\npackage serviceimport (    &quot;context&quot;    &quot;errors&quot;    &quot;github.com/lookupman/service_discovery/config&quot;    &quot;github.com/lookupman/service_discovery/discovery&quot;)//定义服务接口type Service interface &#123;    HealthCheck() bool    SayHello() string&#125;//实现SayHello服务接口type DiscoveryServiceImpl struct &#123;    discoveryClient discovery.DiscoverClient&#125;func NewDiscoveryServiceImpl(discoveryClient discovery.DiscoverClient) Service &#123;    return &amp;DiscoveryServiceImpl&#123;discoveryClient: discoveryClient&#125;&#125;func (service *DiscoveryServiceImpl) HealthCheck() bool &#123;    return true&#125;func (service DiscoveryServiceImpl) SayHello() string &#123;    return &quot;Hello World!&quot;&#125;\n\n定义服务端点（Endpoint）&emsp;&emsp;endpoint是go-kit定义的一个函数类型，定义返回这个类型的函数，传给NewServer作为参数实现对http handler的注册，另外需要定义request解码和response编码的函数。\ntype Endpoint func(ctx context.Context, request interface&#123;&#125;) (response interface&#123;&#125;, err error)\n\npackage endpointimport (\t&quot;context&quot;\t&quot;github.com/go-kit/kit/endpoint&quot;\t&quot;github.com/lookupman/service_discovery/service&quot;)type DiscoveryEndpoints struct &#123;\tSayHelloEndpoint    endpoint.Endpoint\tHealthCheckEndpoint endpoint.Endpoint&#125;type SayHelloRequest struct &#123;&#125;type SayHelloResponse struct &#123;\tMessage string `json:&quot;message&quot;`&#125;func MakeSayHelloEndpoint(svc service.Service) endpoint.Endpoint &#123;\treturn func(ctx context.Context, request interface&#123;&#125;) (response interface&#123;&#125;, err error) &#123;\t\tmessage := svc.SayHello()\t\treturn SayHelloResponse&#123;Message: message&#125;, nil\t&#125;&#125;type HealthRequest struct&#123;&#125;type HealthResponse struct &#123;\tStatus bool `json:&quot;status&quot;`&#125;func MakeHealthCheckEndpoint(svc service.Service) endpoint.Endpoint &#123;\treturn func(ctx context.Context, request interface&#123;&#125;) (response interface&#123;&#125;, err error) &#123;\t\tstatus := svc.HealthCheck()\t\treturn HealthResponse&#123;Status: status&#125;, nil\t&#125;&#125;\n\n定义http层handler&emsp;&emsp;在这里做的是，使用go-kit的库实现对endpoint、编解码函数封装，实现http的handler\npackage transportimport (\t&quot;context&quot;\t&quot;encoding/json&quot;\t&quot;errors&quot;\t&quot;net/http&quot;\t&quot;github.com/go-kit/kit/log&quot;\t&quot;github.com/go-kit/kit/transport&quot;\tkithttp &quot;github.com/go-kit/kit/transport/http&quot;\t&quot;github.com/gorilla/mux&quot;\t&quot;github.com/lookupman/service_discovery/endpoint&quot;)var (\tErrorRequest = errors.New(&quot;invalid request parameter&quot;))func MakeHttpHandler(ctx context.Context, endpoints endpoint.DiscoveryEndpoints, logger log.Logger) http.Handler &#123;\tr := mux.NewRouter()\toptions := []kithttp.ServerOption&#123;\t\tkithttp.ServerErrorHandler(transport.NewLogErrorHandler(logger)),\t\tkithttp.ServerErrorEncoder(encodeError),\t&#125;\tr.Methods(&quot;GET&quot;).Path(&quot;/SayHello&quot;).Handler(kithttp.NewServer(\t\tendpoints.SayHelloEndpoint,\t\tdecodeSayHelloRequest,\t\tencodeJsonResponse,\t\toptions...,\t))\tr.Methods(&quot;GET&quot;).Path(&quot;/health&quot;).Handler(kithttp.NewServer(\t\tendpoints.HealthCheckEndpoint,\t\tdecodeHealthRequest,\t\tencodeJsonResponse,\t\toptions...,\t))\treturn r&#125;func decodeSayHelloRequest(ctx context.Context, req *http.Request) (request interface&#123;&#125;, err error) &#123;\treturn endpoint.SayHelloRequest&#123;&#125;, nil&#125;func decodeHealthRequest(ctx context.Context, req *http.Request) (request interface&#123;&#125;, err error) &#123;\treturn endpoint.HealthRequest&#123;&#125;, nil&#125;func encodeJsonResponse(ctx context.Context, w http.ResponseWriter, response interface&#123;&#125;) error &#123;\tw.Header().Set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;)\treturn json.NewEncoder(w).Encode(response)&#125;func encodeError(ctx context.Context, err error, w http.ResponseWriter) &#123;\tw.Header().Set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;)\tswitch err &#123;\tdefault:\t\tw.WriteHeader(http.StatusInternalServerError)\t&#125;\tjson.NewEncoder(w).Encode(map[string]interface&#123;&#125;&#123;\t\t&quot;error&quot;: err.Error(),\t&#125;)&#125;\n\n主函数&emsp;&emsp;最后是主函数，在这里绑定监听端口以及将服务注册到consul\npackage mainimport (\t&quot;context&quot;\t&quot;fmt&quot;\t&quot;github.com/lookupman/service_discovery/config&quot;\t&quot;github.com/lookupman/service_discovery/discovery&quot;\t&quot;github.com/lookupman/service_discovery/endpoint&quot;\t&quot;github.com/lookupman/service_discovery/service&quot;\t&quot;github.com/lookupman/service_discovery/transport&quot;\tuuid &quot;github.com/satori/go.uuid&quot;\t&quot;log&quot;\t&quot;net/http&quot;\t&quot;os&quot;\t&quot;os/signal&quot;\t&quot;strconv&quot;\t&quot;syscall&quot;)var logger log.Loggerfunc main() &#123;\tserviceHost := &quot;127.0.0.1&quot;\tservicePort := 9999\tserviceName := &quot;SayHello&quot;\tconsulHost := &quot;127.0.0.1&quot;\tconsulPort := 8500\tctx := context.Background()\terrChan := make(chan error)\tvar discoverClient discovery.DiscoverClient\tdiscoverClient, err := discovery.NewKitDiscoverClient(consulHost, consulPort)\tif err != nil &#123;\t\tlog.Println(&quot;Get Consul Client failed&quot;)\t\treturn\t&#125;\tsvc := service.NewDiscoveryServiceImpl(discoverClient)\tsayHelloEndpoint := endpoint.MakeSayHelloEndpoint(svc)\thealthCheckEndpoint := endpoint.MakeHealthCheckEndpoint(svc)\tendpoints := endpoint.DiscoveryEndpoints&#123;\t\tSayHelloEndpoint:    sayHelloEndpoint,\t\tHealthCheckEndpoint: healthCheckEndpoint,\t&#125;\trouter := transport.MakeHttpHandler(ctx, endpoints, config.KitLogger)\tinstanceId := serviceName + &quot;-&quot; + uuid.NewV4().String()\tgo func() &#123;\t\tconfig.Logger.Println(&quot;Http Server start at port:&quot; + strconv.Itoa(servicePort))\t\tif !discoverClient.Register(serviceName, instanceId, &quot;/health&quot;,\t\t\tserviceHost, servicePort, nil, config.Logger) &#123;\t\t\tconfig.Logger.Printf(&quot;string-service for service %s failed.&quot;, serviceName)\t\t\t// 注册失败，服务启动失败\t\t\tos.Exit(-1)\t\t&#125;\t\thandler := router\t\terrChan &lt;- http.ListenAndServe(&quot;:&quot;+strconv.Itoa(servicePort), handler)\t&#125;()\tgo func() &#123;\t\t// 监控系统信号，等待 ctrl + c 系统信号通知服务关闭\t\tc := make(chan os.Signal, 1)\t\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\t\terrChan &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c)    &#125;()    err = &lt;-errChan\t//服务退出取消注册\tdiscoverClient.DeRegister(instanceId, config.Logger)\tconfig.Logger.Println(err)&#125;\n参考文章:Go语言高并发与微服务实战\n","categories":["Golang"]},{"title":"ioutil一些方便的操作函数集","url":"/2020/10/26/ioutil%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86/","content":"\n1. NopCloser函数&emsp;&emsp;该函数是将一个io.Reader接口包装成一个io.ReadCloser接口，其中包装生成的Close方法什么也不操作。可以在需要将io.Reader传入io.ReadCloser参数的函数的情况下使用。\ntype nopCloser struct &#123;    io.Reader&#125;func(nopCloser) Close() error &#123;    return nil&#125;\n\n2. ReadAll函数&emsp;&emsp;很多时候，我们需要一次性读取 io.Reader 中的数据，通过上一节的讲解，我们知道有很多种实现方式。考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。\nfunc ReadAll(r io.Reader) ([]byte, error)\n&emsp;&emsp;阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。该函数成功调用后会返回 err == nil 而不是 err == EOF。(成功读取完毕应该为 err == io.EOF，这里返回 nil 由于该函数成功期望 err == io.EOF，符合无错误不处理的理念)\n参考文章:参考链接\n","categories":["Golang"]},{"title":"新的开始","url":"/2020/06/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/","content":"\n要开始写博客了，不然很多东西，好久没用了就忘了","categories":["生活"],"tags":["成长"]},{"title":"nginx学习记录","url":"/2020/10/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"\n基础架构&emsp;&emsp;\n1.请求流程\n优点\n高并发，高性能\n可扩展性良好\n高可靠性\n热部署\nBSD许可证\n\n–32核64G，可支持千万并发\n组成（1）Nginx二进制可执行文件（2）Nginx。conf配置文件（3）access.log访问日志（4）error.log错误日志\n历史版本\n第三方模块框架OpenResty\n编译nginx\n下载安装nginx\n源码目录\n\n目录说明① auto 用于编译，其中包含了四个主要目录，分别是cc(用于编译)、lib、os(对编译操作系统的判断)、types② CHANGES: nginx的版本变化③ CHANGES.ru: 俄罗斯版本④ conf: 一些示例文件，nginx安装好后为了方便运维去配置，会把conf的示例文件拷贝到安装目录⑤ configure: 该文件用于生成中间文件，执行编译前的必备动作⑥ contrib: 提供2个perl脚本和vim的工具，改变配置nginx.conf的vim语法配色\ncp -r contrib/vim/* ~/.vim/\n⑦ man: nginx帮助文件⑧ src: 源代码\n\n编译\n.&#x2F;configure --help | more\n&emsp;&emsp;如果不需要变动，编译时只需要指定–prefix参数即可，所有的文件会在prefix目录下建相应的文件夹&emsp;&emsp;–with前缀的模块默认不加入编译&emsp;&emsp;–without前缀的模块默认加入编译，执行该命令表示移除编译\n//安装依赖//解决zlib error依赖错误sudo apt install zlib1g-dev//解决openssl error依赖错误sudo apt install openssl libssl-dev//解决pcre error依赖错误sudo apt install libpcre3 libpcre3-dev\n&emsp;&emsp;执行configure，会生成中间文件在objs文件夹下，其中最重要的是ngx_modules.c，它决定了哪些模块将参与编译\n.&#x2F;configure --prefix &#x3D; ~&#x2F;home&#x2F;app&#x2F;nginx\n&emsp;&emsp;接下来是执行make编译，目标文件在objs目录“nginx”，c编译的中间文件在src目录\nmake\n&emsp;&emsp;最后执行安装命令，安装在prefix执行的目录中\nmake install\n\n\n\nnginx命令行&#x2F;&#x2F;使用指定配置文件 -c&#x2F;&#x2F;使用配置指令 -g&#x2F;&#x2F;指定运行目录 -p&#x2F;&#x2F;发送信号 -s&#x2F;&#x2F;&#x2F;&#x2F;stop：立即停止服务    (kill -TERM)&#x2F;&#x2F;&#x2F;&#x2F;quit：优雅的停止服务  (kill -QUIT)&#x2F;&#x2F;&#x2F;&#x2F;reload：重载配置文件  (kill -SIGHUP)&#x2F;&#x2F;&#x2F;&#x2F;reopen：重新开始记录日志文件 (kill -USR1)&#x2F;&#x2F;测试配置文件是否有语法错误 -t -T&#x2F;&#x2F;打印nginx的版本信息、编译信息：-v -V\n&emsp;&emsp;修改配置后，直接nginx -s reload即可，会自动加载新的配置，在这个过程中，会重新启动一个worker进行，并将之前的worker进程优雅的退出\n优雅关闭&emsp;&emsp;优雅的关闭只针对http协议层\n热部署\n\n部署最新版本的nginx，只需替换nginx二进制文件，首先用ps -ef | grep nginx，观察进程的状态。（注意在编译新版本的nginx时，不需要执行make install命令，否则会覆盖之前的配置文件）\n然后将安装目录下sbin/nginx，修改为nginx.oldmv nginx nginx.old\n然后将其他版本的nginx移到该目录下cp ..&#x2F;openresty&#x2F;nginx&#x2F;sbin&#x2F;nginx .&#x2F;\n然后像nginx发送信号(kill -USR2 79637)，其会启动新版本nginx进程kill -USR2 79637\n\n然后向老的nginx进程发送一个信号(kill -WINCH 79637)，让其优雅的关闭work进程kill -WINCH 79637\n\n在这之后可以看到老版本的nginx的worker进程已经关闭，还剩下master进程，master进程是为了防止新部署的版本出现问题，可以做版本回退的作用版本回退\n首先通过信号，kill -HUP 79637重新拉起旧版本的master进程kill -HUP 79637\n\n然后像新版本的nginx，发送kill -WINCH 112586信号使其优雅的关闭worker进程kill -WINCH 112586\n\n最后关闭新版本的nginx master进程即可kill -9 112586\n日志切割\n首先到log目录下，将之前日志转移到另一个文件mv access.log pre_access.log\n然后在nginx目录下，执行reopen命令即可生成新的日志文件sudo nginx -s reopen\nNginx信号&emsp;&emsp;其中master进程会检测worker进程，当worker异常终止时，master进程会接收到一个CHLD信号。然后master进程会重新将worker进程拉起。reload流程（注意配置worker_shutdown_timeout）\n\n使用Goaccess分析日志\n使用apt安装goaccesssudo apt install goaccess\n然后执行一下命令即可。-o 分析日志网页的生成路径，其余参数查看官网帮助文档，其中注意在nginx的日志格式变化的情况下，需要修改–log-foramt参数对应的值goaccess pre_access.log -o ..&#x2F;html&#x2F;report.html --real-time-html --time-format&#x3D;&#39;%H:%M:%S&#39; --date-format&#x3D;&#39;%d&#x2F;%b&#x2F;%Y&#39; --log-format&#x3D;COMBINED\nNginx模块数据结构&emsp;&emsp;其中ngx_module_t中的type字段定义了nginx模块的类型\n\n共享内存使用模块\n参考文章\n极客时间Nginx核心知识100讲\n\n","categories":["Nginx"],"tags":["成长"]},{"title":"gorm学习记录","url":"/2020/11/08/gorm%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"\n安装相应的库&emsp;&emsp;在命令行输入如下命令即可\ngo get -u gorm.io/gormgo get -u gorm.io/driver/mysql\n\n连接数据库&emsp;&emsp;mysql连接连接方式如下，其他数据库的连接方式以及高级配置请看官方文档\ndsn := &quot;root:password@tcp(127.0.0.1:3306)/dbName?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil&#123;    log.Fatal(err)    return&#125;\n\nCRUD接口结构体字段标签主键&emsp;&emsp;在与数据库关联时，会有一些特定的约定，比如主键。在gorm中通过标签进行标识，一般情况下，默认将ID作为表的主键，不过可以使用primaryKey标签进行标识\ntype User struct&#123;    ID string //默认ID字段为主键    Name string&#125;type User struct&#123;    ID string    UUID string `gorm:&quot;primaryKey&quot;` //使用标签primaryKey将UUID标识为主键    Name string&#125;\n表名&emsp;&emsp;通过结构体映射的数据库表明，默认为数据库的名字加上’s’，如User则在数据库中对应的表为users、UserAdmin为user_admins，可以通过定义TableName()方法来，修改映射的数据库名\nfunc(User) TableName() string&#123;    return &quot;admin_user&quot;  //如果字符串为小驼峰或大驼峰，则会转换为全小写&#125;\n\n\n关联数据库表&emsp;&emsp;要对数据进行增删改查，首先要将数据库表和gorm进行关联，在此处是与go的结构体进行关联\n//其中gorm.Model是gorm库默认的一些字段，包括了id，CreatedAt，UpdateAt，DeleteAt这几个字段type Product struct &#123;    gorm.Model    Code string    Price uint&#125;//将结构体与数据库表进行关联，如果数据库中不存在该表，则会自动创建db.AutoMigrate(&amp;Product&#123;&#125;)\n创建&emsp;&emsp;创\n参考文章:参考链接\n","categories":["Golang"]}]