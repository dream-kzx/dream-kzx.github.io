<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lookupman的博客</title>
  
  
  <link href="https://lookupman.cn/atom.xml" rel="self"/>
  
  <link href="https://lookupman.cn/"/>
  <updated>2021-02-25T13:44:56.233Z</updated>
  <id>https://lookupman.cn/</id>
  
  <author>
    <name>lookupman</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go进阶训练营第1周</title>
    <link href="https://lookupman.cn/2021/02/25/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC1%E5%91%A8/"/>
    <id>https://lookupman.cn/2021/02/25/go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC1%E5%91%A8/</id>
    <published>2021-02-25T13:44:36.000Z</published>
    <updated>2021-02-25T13:44:56.233Z</updated>
    
    <content type="html"><![CDATA[<p>首页显示摘要内容（替换成自己的）</p><a id="more"></a><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首页显示摘要内容（替换成自己的）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>go-kit中使用consul服务注册与发现、健康检测</title>
    <link href="https://lookupman.cn/2021/01/03/go-kit%E4%B8%AD%E4%BD%BF%E7%94%A8consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B/"/>
    <id>https://lookupman.cn/2021/01/03/go-kit%E4%B8%AD%E4%BD%BF%E7%94%A8consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B/</id>
    <published>2021-01-03T07:50:42.000Z</published>
    <updated>2021-08-03T12:13:34.182Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本章介绍在go-kit中进行使用服务发现和注册，以及健康检测</p><a id="more"></a><h1 id="首先使用kit提供的库，定义对consul的访问"><a href="#首先使用kit提供的库，定义对consul的访问" class="headerlink" title="首先使用kit提供的库，定义对consul的访问"></a>首先使用kit提供的库，定义对consul的访问</h1><p>&emsp;&emsp;首先定义服务发现的客户端接口，接口需要提供3个方法，服务注册、服务注销以及服务发现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> discovery</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DiscoverClient <span class="keyword">interface</span>&#123;</span><br><span class="line">    Register(serviceName, instanceId, healthCheckUrl <span class="keyword">string</span>,</span><br><span class="line">        instanceHost <span class="keyword">string</span>, instancePort <span class="keyword">int</span>, meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, logger *log.Logger) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    DeRegister(instanceId <span class="keyword">string</span>, logger *log.Logger) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    DiscoveryServices(serviceName <span class="keyword">string</span>, logger *log.Logger) []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后定义对接口的实现，在此处使用go-kit封装的库对接口进行实现，同时在服务发现部分通过map对服务进行缓存，在服务发生变化时，通过获取consul的通知进行更新map</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> discovery</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/sd/consul&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/hashicorp/consul/api&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/hashicorp/consul/api/watch&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KitDiscoverClient <span class="keyword">struct</span> &#123;</span><br><span class="line">consulHost  <span class="keyword">string</span>          <span class="comment">//consul的地址</span></span><br><span class="line">consulPort  <span class="keyword">int</span>             <span class="comment">//consul的端口</span></span><br><span class="line">client      consul.Client   <span class="comment">//kit封装consul的客户端</span></span><br><span class="line">config      *api.Config     <span class="comment">//kit封装的consul配置</span></span><br><span class="line">mutex       sync.Mutex</span><br><span class="line">instanceMap sync.Map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKitDiscoverClient</span><span class="params">(consulHost <span class="keyword">string</span>, consulPort <span class="keyword">int</span>)</span> <span class="params">(DiscoverClient, error)</span></span> &#123;</span><br><span class="line">consulConfig := api.DefaultConfig()</span><br><span class="line">consulConfig.Address = consulHost + <span class="string">&quot;:&quot;</span> + strconv.Itoa(consulPort)</span><br><span class="line">apiClient, err := api.NewClient(consulConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">client := consul.NewClient(apiClient)</span><br><span class="line"><span class="keyword">return</span> &amp;KitDiscoverClient&#123;</span><br><span class="line">consulHost: consulHost,</span><br><span class="line">consulPort: consulPort,</span><br><span class="line">client:     client,</span><br><span class="line">config:     consulConfig,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(consulClient *KitDiscoverClient)</span> <span class="title">Register</span><span class="params">(serviceName, instanceId, healthCheckUrl <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">instanceHost <span class="keyword">string</span>, instancePort <span class="keyword">int</span>, meta <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, logger *log.Logger)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">serviceRegistration := &amp;api.AgentServiceRegistration&#123;</span><br><span class="line">ID:      instanceId,</span><br><span class="line">Name:    serviceName,</span><br><span class="line">Address: instanceHost,</span><br><span class="line">Port:    instancePort,</span><br><span class="line">Meta:    meta,</span><br><span class="line">Check: &amp;api.AgentServiceCheck&#123;</span><br><span class="line">DeregisterCriticalServiceAfter: <span class="string">&quot;30s&quot;</span>,</span><br><span class="line">HTTP:                           <span class="string">&quot;http://&quot;</span> + instanceHost + <span class="string">&quot;:&quot;</span> + strconv.Itoa(instancePort) + healthCheckUrl,</span><br><span class="line">Interval:                       <span class="string">&quot;15s&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := consulClient.client.Register(serviceRegistration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Register Service Error!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Register Service Success!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(consulClient *KitDiscoverClient)</span> <span class="title">DeRegister</span><span class="params">(instanceId <span class="keyword">string</span>, logger *log.Logger)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">serviceRegistration := &amp;api.AgentServiceRegistration&#123;</span><br><span class="line">ID: instanceId,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := consulClient.client.Deregister(serviceRegistration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Println(<span class="string">&quot;Deregister Service Error!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Deregister Service Success!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(consulClient *KitDiscoverClient)</span> <span class="title">DiscoveryServices</span><span class="params">(serviceName <span class="keyword">string</span>, logger *log.Logger)</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">//判断服务是否已缓存</span></span><br><span class="line">instanceList, ok := consulClient.instanceMap.Load(serviceName)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> instanceList.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    consulClient.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> consulClient.mutex.Unlock()</span><br><span class="line">    <span class="comment">//加锁后在判断一次，服务是否已缓存</span></span><br><span class="line">instanceList, ok = consulClient.instanceMap.Load(serviceName)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> instanceList.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应服务变更通知，更新服务map</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">params[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;service&quot;</span></span><br><span class="line">params[<span class="string">&quot;service&quot;</span>] = serviceName</span><br><span class="line">plan, _ := watch.Parse(params)</span><br><span class="line">plan.Handler = <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">uint64</span>, i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v, ok := i.([]*api.ServiceEntry)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span> &#123;</span><br><span class="line">consulClient.instanceMap.Store(serviceName, []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> healthServices []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, service := <span class="keyword">range</span> v &#123;</span><br><span class="line"><span class="keyword">if</span> service.Checks.AggregatedStatus() == api.HealthPassing &#123;</span><br><span class="line">healthServices = <span class="built_in">append</span>(healthServices, service)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">consulClient.instanceMap.Store(serviceName, healthServices)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> plan.Stop()</span><br><span class="line">plan.Run(consulClient.config.Address)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用go-kit库向consul获取服务</span></span><br><span class="line">entries, _, err := consulClient.client.Service(serviceName, <span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">consulClient.instanceMap.Store(serviceName, []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;)</span><br><span class="line">logger.Println(<span class="string">&quot;Discover Service Error&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instances := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(entries))</span><br><span class="line"><span class="keyword">for</span> _, instance := <span class="keyword">range</span> entries &#123;</span><br><span class="line">instances = <span class="built_in">append</span>(instances, instance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consulClient.instanceMap.Store(serviceName, instances)</span><br><span class="line"><span class="keyword">return</span> instances</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h1><p>&emsp;&emsp;定义服务，本文实例定义两个服务：SayHello和HealthCheck。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/lookupman/service_discovery/config&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/lookupman/service_discovery/discovery&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义服务接口</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    HealthCheck() <span class="keyword">bool</span></span><br><span class="line">    SayHello() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现SayHello服务接口</span></span><br><span class="line"><span class="keyword">type</span> DiscoveryServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    discoveryClient discovery.DiscoverClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDiscoveryServiceImpl</span><span class="params">(discoveryClient discovery.DiscoverClient)</span> <span class="title">Service</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DiscoveryServiceImpl&#123;discoveryClient: discoveryClient&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service *DiscoveryServiceImpl)</span> <span class="title">HealthCheck</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service DiscoveryServiceImpl)</span> <span class="title">SayHello</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义服务端点（Endpoint）"><a href="#定义服务端点（Endpoint）" class="headerlink" title="定义服务端点（Endpoint）"></a>定义服务端点（Endpoint）</h1><p>&emsp;&emsp;endpoint是go-kit定义的一个函数类型，定义返回这个类型的函数，传给NewServer作为参数实现对http handler的注册，另外需要定义request解码和response编码的函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Endpoint <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> endpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/service&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DiscoveryEndpoints <span class="keyword">struct</span> &#123;</span><br><span class="line">SayHelloEndpoint    endpoint.Endpoint</span><br><span class="line">HealthCheckEndpoint endpoint.Endpoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SayHelloRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SayHelloResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Message <span class="keyword">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSayHelloEndpoint</span><span class="params">(svc service.Service)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">message := svc.SayHello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SayHelloResponse&#123;Message: message&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HealthRequest <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HealthResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Status <span class="keyword">bool</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHealthCheckEndpoint</span><span class="params">(svc service.Service)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">status := svc.HealthCheck()</span><br><span class="line"><span class="keyword">return</span> HealthResponse&#123;Status: status&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义http层handler"><a href="#定义http层handler" class="headerlink" title="定义http层handler"></a>定义http层handler</h1><p>&emsp;&emsp;在这里做的是，使用go-kit的库实现对endpoint、编解码函数封装，实现http的handler</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transport</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/transport&quot;</span></span><br><span class="line">kithttp <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/endpoint&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrorRequest = errors.New(<span class="string">&quot;invalid request parameter&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeHttpHandler</span><span class="params">(ctx context.Context, endpoints endpoint.DiscoveryEndpoints, logger log.Logger)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">r := mux.NewRouter()</span><br><span class="line"></span><br><span class="line">options := []kithttp.ServerOption&#123;</span><br><span class="line">kithttp.ServerErrorHandler(transport.NewLogErrorHandler(logger)),</span><br><span class="line">kithttp.ServerErrorEncoder(encodeError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.Methods(<span class="string">&quot;GET&quot;</span>).Path(<span class="string">&quot;/SayHello&quot;</span>).Handler(kithttp.NewServer(</span><br><span class="line">endpoints.SayHelloEndpoint,</span><br><span class="line">decodeSayHelloRequest,</span><br><span class="line">encodeJsonResponse,</span><br><span class="line">options...,</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">r.Methods(<span class="string">&quot;GET&quot;</span>).Path(<span class="string">&quot;/health&quot;</span>).Handler(kithttp.NewServer(</span><br><span class="line">endpoints.HealthCheckEndpoint,</span><br><span class="line">decodeHealthRequest,</span><br><span class="line">encodeJsonResponse,</span><br><span class="line">options...,</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeSayHelloRequest</span><span class="params">(ctx context.Context, req *http.Request)</span> <span class="params">(request <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> endpoint.SayHelloRequest&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeHealthRequest</span><span class="params">(ctx context.Context, req *http.Request)</span> <span class="params">(request <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> endpoint.HealthRequest&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeJsonResponse</span><span class="params">(ctx context.Context, w http.ResponseWriter, response <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeError</span><span class="params">(ctx context.Context, err error, w http.ResponseWriter)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> err &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">&#125;</span><br><span class="line">json.NewEncoder(w).Encode(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><p>&emsp;&emsp;最后是主函数，在这里绑定监听端口以及将服务注册到consul</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/config&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/discovery&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/service&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/lookupman/service_discovery/transport&quot;</span></span><br><span class="line">uuid <span class="string">&quot;github.com/satori/go.uuid&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger log.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">serviceHost := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">servicePort := <span class="number">9999</span></span><br><span class="line">serviceName := <span class="string">&quot;SayHello&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consulHost := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">consulPort := <span class="number">8500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctx := context.Background()</span><br><span class="line">errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> discoverClient discovery.DiscoverClient</span><br><span class="line">discoverClient, err := discovery.NewKitDiscoverClient(consulHost, consulPort)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Get Consul Client failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">svc := service.NewDiscoveryServiceImpl(discoverClient)</span><br><span class="line"></span><br><span class="line">sayHelloEndpoint := endpoint.MakeSayHelloEndpoint(svc)</span><br><span class="line">healthCheckEndpoint := endpoint.MakeHealthCheckEndpoint(svc)</span><br><span class="line"></span><br><span class="line">endpoints := endpoint.DiscoveryEndpoints&#123;</span><br><span class="line">SayHelloEndpoint:    sayHelloEndpoint,</span><br><span class="line">HealthCheckEndpoint: healthCheckEndpoint,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router := transport.MakeHttpHandler(ctx, endpoints, config.KitLogger)</span><br><span class="line"></span><br><span class="line">instanceId := serviceName + <span class="string">&quot;-&quot;</span> + uuid.NewV4().String()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">config.Logger.Println(<span class="string">&quot;Http Server start at port:&quot;</span> + strconv.Itoa(servicePort))</span><br><span class="line"><span class="keyword">if</span> !discoverClient.Register(serviceName, instanceId, <span class="string">&quot;/health&quot;</span>,</span><br><span class="line">serviceHost, servicePort, <span class="literal">nil</span>, config.Logger) &#123;</span><br><span class="line">config.Logger.Printf(<span class="string">&quot;string-service for service %s failed.&quot;</span>, serviceName)</span><br><span class="line"><span class="comment">// 注册失败，服务启动失败</span></span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handler := router</span><br><span class="line">errChan &lt;- http.ListenAndServe(<span class="string">&quot;:&quot;</span>+strconv.Itoa(servicePort), handler)</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监控系统信号，等待 ctrl + c 系统信号通知服务关闭</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">errChan &lt;- fmt.Errorf(<span class="string">&quot;%s&quot;</span>, &lt;-c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = &lt;-errChan</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务退出取消注册</span></span><br><span class="line">discoverClient.DeRegister(instanceId, config.Logger)</span><br><span class="line">config.Logger.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="">Go语言高并发与微服务实战</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;本章介绍在go-kit中进行使用服务发现和注册，以及健康检测&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>go-kit/etcdv3库学习</title>
    <link href="https://lookupman.cn/2020/12/06/go-kit-etcdv3%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lookupman.cn/2020/12/06/go-kit-etcdv3%E5%BA%93%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-06T12:08:01.000Z</published>
    <updated>2020-12-06T14:23:42.186Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本章介绍使用go-kit的工具包etcdv3进行对etcd做服务注册和发现操作</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="etcd的key-value存储和查找方式"><a href="#etcd的key-value存储和查找方式" class="headerlink" title="etcd的key-value存储和查找方式"></a>etcd的key-value存储和查找方式</h2><p>&emsp;&emsp;etcd是使用key-value的形式进行存储的，与consul不同的是，etcd的查找是通过前缀进行查找的。举个例子，服务名为hellworld的服务部署了3个实例在不同的服务器上：<br>&emsp;&emsp;”<a href="http://192.168.10.111:8888&quot;">http://192.168.10.111:8888&quot;</a><br>&emsp;&emsp;”<a href="http://192.168.10.112:8888&quot;">http://192.168.10.112:8888&quot;</a><br>&emsp;&emsp;”<a href="http://192.168.10.113:8888&quot;">http://192.168.10.113:8888&quot;</a><br>那么在etcd服务器中存储的值一般的存储方式为：<br>key1 = “/service/helloworld/192.168.10.111:8888” value1 = “<a href="http://192.168.10.111:8888&quot;">http://192.168.10.111:8888&quot;</a><br>key2 = “/service/helloworld/192.168.10.112:8888” value2 = “<a href="http://192.168.10.112:8888&quot;">http://192.168.10.112:8888&quot;</a><br>key3 = “/service/helloworld/192.168.10.113:8888” value3 = “<a href="http://192.168.10.113:8888&quot;">http://192.168.10.113:8888&quot;</a><br>&emsp;&emsp;那么在服务发现时，就通过查找前缀为”/service/helloworld/“的所有的key-value，etcd就会返回前缀为”/service/helloworld/“所有的值。</p><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>&emsp;&emsp;go-kit提供了对etcd进行服务注册的封装的函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ClientOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">Cert          <span class="keyword">string</span>    <span class="comment">//用于SSL</span></span><br><span class="line">Key           <span class="keyword">string</span>    <span class="comment">//用于SSL</span></span><br><span class="line">CACert        <span class="keyword">string</span>    <span class="comment">//用于SSL</span></span><br><span class="line">DialTimeout   time.Duration     <span class="comment">//建立连接失败的超时时间</span></span><br><span class="line">DialKeepAlive time.Duration     <span class="comment">//存活检测时间</span></span><br><span class="line">Username      <span class="keyword">string</span>            <span class="comment">//etcd的用户名，未在etcd中设置，则不需要</span></span><br><span class="line">Password      <span class="keyword">string</span>            <span class="comment">//etcd的密码，未在etcd中设置，则不需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//etcd创建客户端接口，machines为etcd的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(ctx context.Context, machines []<span class="keyword">string</span>, options ClientOptions)</span> <span class="params">(Client, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="keyword">string</span>        <span class="comment">//存储在etcd的key</span></span><br><span class="line">Value <span class="keyword">string</span>        <span class="comment">//存储在etcd的value</span></span><br><span class="line">TTL   *TTLOption    <span class="comment">//心跳检测时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewRegistrar</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRegistrar</span><span class="params">(client Client, service Service, logger log.Logger)</span> *<span class="title">Registrar</span></span></span><br></pre></td></tr></table></figure><p>使用etcdv3进行服务注册，etcdv3的接口中封装了对etcd存活检测的操作</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    etcdHost := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    etcdPort := <span class="number">2379</span></span><br><span class="line"></span><br><span class="line">    serviceHost := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    servicePort := <span class="number">8888</span></span><br><span class="line">    serviceName := <span class="string">&quot;service/hellworld&quot;</span></span><br><span class="line"></span><br><span class="line">    ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    clientOption := etcdv3.ClientOption&#123;</span><br><span class="line">        DialTimeout: <span class="number">3</span> * time.Second,</span><br><span class="line">        DialKeepAlive: <span class="number">3</span>* time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr := etcdHost+<span class="string">&quot;:&quot;</span>+strconv.Itoa(etcdPort)</span><br><span class="line">    <span class="comment">//创建etcd客户端</span></span><br><span class="line">    client, err := etcdv3.NewClient(ctx, []<span class="keyword">string</span>&#123;addr&#125;, clientOption)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr := serviceHost + <span class="string">&quot;:&quot;</span> + strconv.Itoa(servicePort)</span><br><span class="line">    key := <span class="keyword">string</span>.TrimRight(serviceName, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span> + addr</span><br><span class="line">    value := <span class="string">&quot;http://&quot;</span> + addr</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建注册器</span></span><br><span class="line">    registrar := etcdv3.NewRegistrar(client, etcdv3.Service&#123;Key: key, Value: value&#125;, kitlog.NewNopLogger())</span><br><span class="line">    <span class="comment">//服务注册</span></span><br><span class="line">    registrar.Registrar()</span><br><span class="line"></span><br><span class="line">    errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        errChan &lt;- http.ListenAndServe(:+strconv.Itoa(servicePort, <span class="literal">nil</span>))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">        errChan &lt;- fmt.Errorf(<span class="string">&quot;%s&quot;</span>, &lt;-c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := &lt;-errChan</span><br><span class="line">    registrar.DeRegister()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>&emsp;&emsp;etcdv3中同样封装了服务发现的接口，同时接口提供了服务变更时通知的接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    etcdHost := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    etcdPort := <span class="number">2379</span></span><br><span class="line"></span><br><span class="line">    prefix := <span class="string">&quot;/service/helloworld/&quot;</span></span><br><span class="line"></span><br><span class="line">    ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    clientOption := etcdv3.ClientOption&#123;</span><br><span class="line">        DialTimeout: <span class="number">3</span> * time.Second,</span><br><span class="line">        DialKeepAlive: <span class="number">3</span>* time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr := etcdHost+<span class="string">&quot;:&quot;</span>+strconv.Itoa(etcdPort)</span><br><span class="line">    <span class="comment">//创建etcd客户端</span></span><br><span class="line">    client, err := etcdv3.NewClient(ctx, []<span class="keyword">string</span>&#123;addr&#125;, clientOption)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instancer, err := etcdv3.NewInstancer(client, prefix, kitlog.NewNopLogger())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> sd.Event)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将chan注册到instancer中，当服务发生变化时，会将新的数据更新到chan</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instancer.Register(ch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取更新的值</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> event := <span class="keyword">range</span> ch&#123;</span><br><span class="line">            <span class="keyword">if</span> event.Err != <span class="literal">nil</span>&#123;</span><br><span class="line">                log.Println(event.Err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fmt.Println(<span class="string">&quot;service url is: &quot;</span>, event.Instances)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">        signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">        errChan &lt;- fmt.Errorf(<span class="string">&quot;%s&quot;</span>, &lt;-c)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := &lt;-errChan</span><br><span class="line">    instancer.DeRegister(ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自己的接口封装"><a href="#自己的接口封装" class="headerlink" title="自己的接口封装"></a>自己的接口封装</h1><p>&emsp;&emsp;为了简化以后的使用，自己封装了一个结构体，不足之处请指出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> common</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/sd&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    kitlog <span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-kit/kit/sd/etcdv3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EtcdV3DiscoverClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    client    etcdv3.Client</span><br><span class="line">    registrar *etcdv3.Registrar</span><br><span class="line"></span><br><span class="line">    instanceMutex sync.Mutex</span><br><span class="line">    instances     <span class="keyword">map</span>[<span class="keyword">string</span>]*etcdv3.Instancer</span><br><span class="line"></span><br><span class="line">    serviceMutex sync.Mutex</span><br><span class="line">    serviceUrls  <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEctdV3DiscoverClient</span><span class="params">(ectdHost <span class="keyword">string</span>, ectdPort <span class="keyword">int</span>)</span> *<span class="title">EtcdV3DiscoverClient</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line"></span><br><span class="line">    clientOption := etcdv3.ClientOptions&#123;</span><br><span class="line">        DialTimeout:   <span class="number">3</span> * time.Second,</span><br><span class="line">        DialKeepAlive: <span class="number">3</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr := ectdHost + <span class="string">&quot;:&quot;</span> + strconv.Itoa(ectdPort)</span><br><span class="line">    client, err := etcdv3.NewClient(ctx, []<span class="keyword">string</span>&#123;addr&#125;, clientOption)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;EtcdV3DiscoverClient&#123;</span><br><span class="line">        client: client,</span><br><span class="line">        instances: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*etcdv3.Instancer),</span><br><span class="line">        serviceUrls: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *EtcdV3DiscoverClient)</span> <span class="title">Register</span><span class="params">(serviceName <span class="keyword">string</span>, serviceHost <span class="keyword">string</span>, servicePort <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    addr := serviceHost + <span class="string">&quot;:&quot;</span> + strconv.Itoa(servicePort)</span><br><span class="line">    key := strings.TrimRight(serviceName, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span> + addr</span><br><span class="line">    value := <span class="string">&quot;http://&quot;</span> + addr</span><br><span class="line"></span><br><span class="line">    cli.registrar = etcdv3.NewRegistrar(cli.client, etcdv3.Service&#123;Key: key, Value: value&#125;, kitlog.NewNopLogger())</span><br><span class="line">    cli.registrar.Register()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *EtcdV3DiscoverClient)</span> <span class="title">DeRegister</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli.registrar.Deregister()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *EtcdV3DiscoverClient)</span> <span class="title">DiscoveryServices</span><span class="params">(serviceName <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    prefix := strings.TrimRight(serviceName, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span></span><br><span class="line"></span><br><span class="line">    cli.instanceMutex.Lock()</span><br><span class="line">    instancer, ok := cli.instances[serviceName]</span><br><span class="line">    cli.instanceMutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        instancer, err = etcdv3.NewInstancer(cli.client, prefix, kitlog.NewNopLogger())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cli.serviceMutex.Lock()</span><br><span class="line">        cli.instances[serviceName] = instancer</span><br><span class="line">        cli.serviceMutex.Unlock()</span><br><span class="line"></span><br><span class="line">        cli.watch(instancer, serviceName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cli.client.GetEntries(prefix)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cli.serviceMutex.Lock()</span><br><span class="line">    serviceUrl, ok := cli.serviceUrls[serviceName]</span><br><span class="line">    cli.serviceMutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;no service url&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceUrl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *EtcdV3DiscoverClient)</span> <span class="title">watch</span><span class="params">(instancer *etcdv3.Instancer , serviceName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> sd.Event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instancer.Register(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> event := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> event.Err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cli.serviceMutex.Lock()</span><br><span class="line">            cli.serviceUrls[serviceName] = event.Instances</span><br><span class="line">            log.Println(time.Now())</span><br><span class="line">            cli.serviceMutex.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">        instancer.Deregister(ch)</span><br><span class="line">        cli.instanceMutex.Lock()</span><br><span class="line">        <span class="built_in">delete</span>(cli.instances, serviceName)</span><br><span class="line">        cli.instanceMutex.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章:</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;本章介绍使用go-kit的工具包etcdv3进行对etcd做服务注册和发现操作&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux安装Go语言</title>
    <link href="https://lookupman.cn/2020/11/14/Linux%E5%AE%89%E8%A3%85Go%E8%AF%AD%E8%A8%80/"/>
    <id>https://lookupman.cn/2020/11/14/Linux%E5%AE%89%E8%A3%85Go%E8%AF%AD%E8%A8%80/</id>
    <published>2020-11-14T08:16:40.000Z</published>
    <updated>2020-11-14T09:03:19.625Z</updated>
    
    <content type="html"><![CDATA[<p>本章介绍在linux下安装go语言，以及一些环境变量的配置，本文的运行环境为ubuntu系统</p><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>在ubuntu中，可以直接使用apt-get命令来安装golang，但是由于apt源中的golang通常不是最新的，所以本章使用下载的二进制包进行安装golang。</p><h1 id="获取golang"><a href="#获取golang" class="headerlink" title="获取golang"></a>获取golang</h1><p>进入<a href="https://golang.org/">Golang官网</a>，点击Download Go，进入下载界面，选择Linux版本tar.gz文件，右键选择复制链接地址。<br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/Golang%E4%B8%8B%E8%BD%BD.png"></p><p>进入ubuntu的bash界面，输入命令，下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.org/dl/go1.15.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>第二步解压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf go1.15.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><p>对于解压后的压缩包，设置相应的环境变量之后即可运行Golang，环境变量设置如下.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入根目录</span></span><br><span class="line">&gt; <span class="built_in">cd</span> ~/</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑.bashrc文件</span></span><br><span class="line">&gt; sudo vim .bashrc</span><br><span class="line"><span class="comment">#在文件最下面，设置Golang相关环境变量</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct</span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="built_in">export</span> GOROOT= <span class="string">&quot;解压压缩包路径&quot;</span></span><br><span class="line"><span class="built_in">export</span> GOPATH= <span class="string">&quot;自定义路径，用于保存一些第三方包&quot;</span></span><br><span class="line">PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$GOPATH</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存.bashrc文件，执行如下命令即可</span></span><br><span class="line"><span class="built_in">source</span> ./bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试是否配置成功</span></span><br><span class="line">&gt; go version</span><br><span class="line">go version go1.15.5 linux/amd64</span><br></pre></td></tr></table></figure><h2 id="环境变量的描述"><a href="#环境变量的描述" class="headerlink" title="环境变量的描述"></a>环境变量的描述</h2><ul><li>GOPROXY：由于国内的网络访问外网较慢，所以在下载第三方包，会出现超时的情况，所以国内大佬们搭建了库的镜像，该配置就是为了配置代理。</li><li>GO111MODULE：启用go module，go module是在go1.11版本加入的，一种包管理的工具</li><li>GOROOT：这个就不解释了</li><li>GOPATH：第三方包下载保存的路径，包括了go module管理包的路径</li></ul><h1 id="解决一些小问题"><a href="#解决一些小问题" class="headerlink" title="解决一些小问题"></a>解决一些小问题</h1><p>在需要使用sudo命令进行编译运行golang时，已设置的环境变量会被置为默认，比如gopath路径被改变，程序所需要依赖的包在编译时就需要重新下载。可以通过如下配置进行设置，在sudo的情况下环境变量不被清空。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入如下文件</span></span><br><span class="line">&gt; sudo visudo /etc/sudoers</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加如下命令即可</span></span><br><span class="line">Defaults !env_reset</span><br><span class="line"><span class="comment">#同时需要注释掉</span></span><br><span class="line">Defaults secure_path=<span class="string">&quot;****&quot;</span></span><br></pre></td></tr></table></figure><p>参考文章:</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章介绍在linux下安装go语言，以及一些环境变量的配置，本文的运行环境为ubuntu系统&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>gorm学习记录</title>
    <link href="https://lookupman.cn/2020/11/08/gorm%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://lookupman.cn/2020/11/08/gorm%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-11-08T08:29:08.000Z</published>
    <updated>2020-11-08T16:03:10.157Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="安装相应的库"><a href="#安装相应的库" class="headerlink" title="安装相应的库"></a>安装相应的库</h1><p>&emsp;&emsp;在命令行输入如下命令即可</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u gorm.io/gorm</span><br><span class="line"><span class="keyword">go</span> get -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>&emsp;&emsp;mysql连接连接方式如下，其他数据库的连接方式以及高级配置请看<a href="https://gorm.io/zh_CN/docs/connecting_to_the_database.html">官方文档</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/dbName?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h1><h2 id="结构体字段标签"><a href="#结构体字段标签" class="headerlink" title="结构体字段标签"></a>结构体字段标签</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>&emsp;&emsp;在与数据库关联时，会有一些特定的约定，比如主键。在gorm中通过标签进行标识，一般情况下，默认将ID作为表的主键，不过可以使用primaryKey标签进行标识</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    ID <span class="keyword">string</span> <span class="comment">//默认ID字段为主键</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    ID <span class="keyword">string</span></span><br><span class="line">    UUID <span class="keyword">string</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span> <span class="comment">//使用标签primaryKey将UUID标识为主键</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h3><p>&emsp;&emsp;通过结构体映射的数据库表明，默认为数据库的名字加上’s’，如User则在数据库中对应的表为users、UserAdmin为user_admins，可以通过定义TableName()方法来，修改映射的数据库名</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(User)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin_user&quot;</span>  <span class="comment">//如果字符串为小驼峰或大驼峰，则会转换为全小写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联数据库表"><a href="#关联数据库表" class="headerlink" title="关联数据库表"></a>关联数据库表</h2><p>&emsp;&emsp;要对数据进行增删改查，首先要将数据库表和gorm进行关联，在此处是与go的结构体进行关联</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中gorm.Model是gorm库默认的一些字段，包括了id，CreatedAt，UpdateAt，DeleteAt这几个字段</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Code <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将结构体与数据库表进行关联，如果数据库中不存在该表，则会自动创建</span></span><br><span class="line">db.AutoMigrate(&amp;Product&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>&emsp;&emsp;创</p><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;安装相应的库&quot;&gt;&lt;a href=&quot;#安装相应的库&quot; class=&quot;headerlink&quot; title=&quot;安装相应的库&quot;&gt;&lt;/a&gt;安装相应的库&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在命令行输入如下命令即可&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>ioutil一些方便的操作函数集</title>
    <link href="https://lookupman.cn/2020/10/26/ioutil%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86/"/>
    <id>https://lookupman.cn/2020/10/26/ioutil%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86/</id>
    <published>2020-10-26T14:31:41.000Z</published>
    <updated>2020-11-08T13:24:03.759Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="1-NopCloser函数"><a href="#1-NopCloser函数" class="headerlink" title="1. NopCloser函数"></a>1. NopCloser函数</h1><p>&emsp;&emsp;该函数是将一个io.Reader接口包装成一个io.ReadCloser接口，其中包装生成的Close方法什么也不操作。可以在需要将io.Reader传入io.ReadCloser参数的函数的情况下使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nopCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(nopCloser)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-ReadAll函数"><a href="#2-ReadAll函数" class="headerlink" title="2. ReadAll函数"></a>2. ReadAll函数</h1><p>&emsp;&emsp;很多时候，我们需要一次性读取 io.Reader 中的数据，通过上一节的讲解，我们知道有很多种实现方式。考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。该函数成功调用后会返回 err == nil 而不是 err == EOF。(成功读取完毕应该为 err == io.EOF，这里返回 nil 由于该函数成功期望 err == io.EOF，符合无错误不处理的理念)</p><p>参考文章:<br><a href="">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-NopCloser函数&quot;&gt;&lt;a href=&quot;#1-NopCloser函数&quot; class=&quot;headerlink&quot; title=&quot;1. NopCloser函数&quot;&gt;&lt;/a&gt;1. NopCloser函数&lt;/h1&gt;&lt;p&gt;&amp;emsp;</summary>
      
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang基本输入输出(io包接口)</title>
    <link href="https://lookupman.cn/2020/10/25/Golang%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA(io%E5%8C%85%E6%8E%A5%E5%8F%A3)/"/>
    <id>https://lookupman.cn/2020/10/25/Golang%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA(io%E5%8C%85%E6%8E%A5%E5%8F%A3)/</id>
    <published>2020-10-25T08:22:58.000Z</published>
    <updated>2020-11-28T06:39:17.042Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在本章的所有的io接口时，有一个特点，在读取或写入的n=len(p)时，返回的接口err=nil或者err=EOF；当n&lt;len(p)时，需要返回err解释原因。</p><a id="more"></a><h1 id="1-Reader接口"><a href="#1-Reader接口" class="headerlink" title="1. Reader接口"></a>1. Reader接口</h1><p>&emsp;&emsp;在官方io包中定义了如下接口，只要实现了Read方法，就是将其传递为io.Reader类型的参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Writer接口"><a href="#2-Writer接口" class="headerlink" title="2. Writer接口"></a>2. Writer接口</h1><p>&emsp;&emsp;在官方的io包中定义里如下接口，只要实现了Write方法，也就是实现了Writer接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-实现Reader和Writer接口的类型"><a href="#3-实现Reader和Writer接口的类型" class="headerlink" title="3. 实现Reader和Writer接口的类型"></a>3. 实现Reader和Writer接口的类型</h1><ul><li>os.File同时实现了io.Reader和io.Writer接口</li><li>strings.Reader实现了io.Reader接口</li><li>bufio.Reader/Writer分别实现了io.Reader和io.Writer接口</li><li>bytes.Buffer同时实现了io.Reader和io.Writer接口</li><li>bytes.Reader实现了io.Reader接口</li><li>compress/gzip.StreamReader/StreamWriter分别实现了io.Reader和io.Writer接口</li><li>encoding/csv.Reader/Writer分别实现了io.Reader和io.Writer接口</li><li>net/conn分别实现了io.Reader和io.Writer接口(Conn接口定义了Read/Write)<h1 id="4-ReaderAt接口"><a href="#4-ReaderAt接口" class="headerlink" title="4. ReaderAt接口"></a>4. ReaderAt接口</h1>&emsp;&emsp;该接口是从源输入的偏移量off处读取len(p)个字节到p中。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderAt <span class="keyword">struct</span> &#123;</span><br><span class="line">    ReadAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-WriterAt接口"><a href="#5-WriterAt接口" class="headerlink" title="5. WriterAt接口"></a>5. WriterAt接口</h1>&emsp;&emsp;该接口是在源输出的偏移量off处写入len(p)个字节。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterAt <span class="keyword">struct</span> &#123;</span><br><span class="line">    WriteAt(p []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-ReaderFrom接口"><a href="#6-ReaderFrom接口" class="headerlink" title="6. ReaderFrom接口"></a>6. ReaderFrom接口</h1>&emsp;&emsp;ReadFrom从r中读取数据，直到EOF或发生错误。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReaderFrom <span class="keyword">struct</span> &#123;</span><br><span class="line">    ReadFrom(r Reader)(n <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用示例<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;writerAt.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    painc(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(os.Stdout)</span><br><span class="line">writer.ReadFrom(file)</span><br><span class="line">writer.Flush()</span><br></pre></td></tr></table></figure><h1 id="7-WriterTo接口"><a href="#7-WriterTo接口" class="headerlink" title="7. WriterTo接口"></a>7. WriterTo接口</h1>&emsp;emsp;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriterTo <span class="keyword">struct</span>&#123;</span><br><span class="line">    WriteTo(w Writer)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-Seeker接口"><a href="#8-Seeker接口" class="headerlink" title="8. Seeker接口"></a>8. Seeker接口</h1>&emsp;&emsp;Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    SeekStart = <span class="number">0</span></span><br><span class="line">    SeekCurrent = <span class="number">1</span></span><br><span class="line">    SeekEnd = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">struct</span>&#123;</span><br><span class="line">    Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)(ret <span class="keyword">int64</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-Closer接口"><a href="#9-Closer接口" class="headerlink" title="9. Closer接口"></a>9. Closer接口</h1>接口定义如下：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="10-ByteReader和ByteWriter接口"><a href="#10-ByteReader和ByteWriter接口" class="headerlink" title="10. ByteReader和ByteWriter接口"></a>10. ByteReader和ByteWriter接口</h1><p>&emsp;&emsp;这个两个接口用于读/写一个字节</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span>&#123;</span><br><span class="line">    ReadByte()(c <span class="keyword">byte</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">    WriteByte(c <span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>在标准库中，有如下类型实现了 io.ByteReader 或 io.ByteWriter:</b><br>bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriter<br>bytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriter<br>bytes.Reader 实现了 io.ByteReader<br>strings.Reader 实现了 io.ByteReader</p><h1 id="11-ByteScanner、RuneReader和RuneScanner接口"><a href="#11-ByteScanner、RuneReader和RuneScanner接口" class="headerlink" title="11. ByteScanner、RuneReader和RuneScanner接口"></a>11. ByteScanner、RuneReader和RuneScanner接口</h1><p>&emsp;&emsp;UnreadByte 方法的意思是：将上一次 ReadByte 的字节还原，使得再次调用 ReadByte 返回的结果和上一次调用相同，也就是说，UnreadByte 是重置上一次的 ReadByte。注意，UnreadByte 调用之前必须调用了 ReadByte，且不能连续调用 UnreadByte。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    ByteReader</span><br><span class="line">    UnreadByte() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuneReader和ByteReader类似</span></span><br><span class="line"><span class="keyword">type</span> RuneReader <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadRune()(r <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RuneScanner和ByteScanner类似</span></span><br><span class="line"><span class="keyword">type</span> RuneScanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    RuneReader</span><br><span class="line">    UnreadRune() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-SectionReader接口"><a href="#12-SectionReader接口" class="headerlink" title="12. SectionReader接口"></a>12. SectionReader接口</h1><p>&emsp;&emsp;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。<br>这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SectionReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    r       ReaderAt</span><br><span class="line">    base    <span class="keyword">int64</span>  <span class="comment">//NewSectionReader会将base设置为off</span></span><br><span class="line">    off     <span class="keyword">int64</span>  <span class="comment">//从r中off偏移处开始读取数据</span></span><br><span class="line">    limit   <span class="keyword">int64</span>  <span class="comment">//limit-off = SectionReader流的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSectionReader</span><span class="params">(r ReaderAt, off <span class="keyword">int64</span>, n <span class="keyword">int64</span>)</span> *<span class="title">SectionReader</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li>LimitedReader接口<br>&emsp;&emsp;从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。也就是说，最多只能返回 N 字节数据。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    R Reader <span class="comment">//underlying reader,最终的读取通过R.Read完成</span></span><br><span class="line">    N <span class="keyword">int64</span> <span class="comment">//max bytes remaining</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;&emsp;使用示例<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">content := <span class="string">&quot;This is LimitReader Example&quot;</span></span><br><span class="line">reader := strings.NewReader(content)</span><br><span class="line">limitReader := &amp;io.LimitedReader&#123;R:reader, N:<span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> limitReader.N &gt; <span class="number">0</span>&#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    limitReader.Read(tmp)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&quot;</span>, tmp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： This Is</span></span><br><span class="line"><span class="comment">//从结果看一看出最多只能读取N个字符</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="14-PipeReader和PipeWriter接口"><a href="#14-PipeReader和PipeWriter接口" class="headerlink" title="14. PipeReader和PipeWriter接口"></a>14. PipeReader和PipeWriter接口</h1><p>&emsp;&emsp;关于 PipeReader.Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 error（即调用 CloseWithError 关闭），该Read返回的 err 就是写入端传递的error；否则 err 为 EOF。<br>&emsp;&emsp;关于 PipeWriter.Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时带有 error（即调用 CloseWithError 关闭），该Write返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PipeReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    p *pipe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PipeWriter <span class="keyword">struct</span>&#123;</span><br><span class="line">    p *pipe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用示例如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pipeReader, pipeWriter := io.Pipe()</span><br><span class="line">    <span class="keyword">go</span> PipeWrite(pipeWriter)</span><br><span class="line">    <span class="keyword">go</span> PipeRead(pipeReader)</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PipeWrite</span><span class="params">(writer *io.PipeWriter)</span></span>&#123;</span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">        n, err := writer.Write(data)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;写入字节%d\n&quot;</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    writer.CloseWithError(errors.New(<span class="string">&quot;写入段已经关闭！&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PipeRead</span><span class="params">(reader *io.PipeReader)</span></span>&#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;接口开始测试....&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">        n, err := reader.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;收到%d个字节，数据为：%s\n&quot;</span>, n, buf)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-Copy和CopyN函数"><a href="#15-Copy和CopyN函数" class="headerlink" title="15. Copy和CopyN函数"></a>15. Copy和CopyN函数</h1><p>&emsp;&emsp;Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。<br>&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span><span class="params">(written <span class="keyword">int64</span>, err error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CopyN 将 n 个字节(或到一个error)从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当err == nil时,written == n 。<br>&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyN</span><span class="params">(dst Writer, src Reader, n <span class="keyword">int64</span>)</span><span class="params">(written <span class="keyword">int64</span>, err error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="16-ReadAtLeast和ReadFull函数"><a href="#16-ReadAtLeast和ReadFull函数" class="headerlink" title="16. ReadAtLeast和ReadFull函数"></a>16. ReadAtLeast和ReadFull函数</h1><p>&emsp;&emsp;ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个EOF 发生在读取了少于min个字节之后，ReadAtLeast就会返回ErrUnexpectedEOF。若 min 大于 buf 的长度，ReadAtLeast 就会返回ErrShortBuffer。对于返回值，当且仅当 err == nil 时，才有 n &gt;= min。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAtLeast</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>, min <span class="keyword">int</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF。对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><h1 id="17-WriteString函数"><a href="#17-WriteString函数" class="headerlink" title="17. WriteString函数"></a>17. WriteString函数</h1><p>&emsp;&emsp;WriteString 将s的内容写入w中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w writer, s <span class="keyword">string</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><h1 id="18-MultiReader和MultiWriter函数"><a href="#18-MultiReader和MultiWriter函数" class="headerlink" title="18. MultiReader和MultiWriter函数"></a>18. MultiReader和MultiWriter函数</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> multiReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    readers []Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> multiWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    writers []Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiReader</span><span class="params">(readers ...Reader)</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiWriter</span><span class="params">(writers ...Writer)</span> <span class="title">Writer</span></span></span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">readers := []io.Reader&#123;</span><br><span class="line">    strings.NewReader(<span class="string">&quot;from strings reader&quot;</span>),</span><br><span class="line">    bytes.NewBufferString(<span class="string">&quot;from bytes buffer&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">reader := io.MultiReader(readers...)</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">128</span>)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    data = <span class="built_in">append</span>(data,buf[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//from strings readerfrom bytes buffer</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Create(<span class="string">&quot;tmp.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writers := []io.Writer&#123;</span><br><span class="line">    file,</span><br><span class="line">    os.Stdout,</span><br><span class="line">&#125;</span><br><span class="line">writer := io.MultiWriter(writers...)</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Hello World!&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：控制台和文件同时输出Hello World!</span></span><br></pre></td></tr></table></figure><p>参考文章:<br><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.1.html">《Go语言标准库》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;在本章的所有的io接口时，有一个特点，在读取或写入的n=len(p)时，返回的接口err=nil或者err=EOF；当n&amp;lt;len(p)时，需要返回err解释原因。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://lookupman.cn/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx学习记录</title>
    <link href="https://lookupman.cn/2020/10/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://lookupman.cn/2020/10/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-10-18T09:23:54.000Z</published>
    <updated>2020-10-18T09:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><p>&emsp;&emsp;<img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx.png" alt="基础架构-w50"></p><h3 id="1-请求流程"><a href="#1-请求流程" class="headerlink" title="1.请求流程"></a>1.请求流程</h3><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/request_process.png" alt="请求流程"></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol><li>高并发，高性能</li><li>可扩展性良好</li><li>高可靠性</li><li>热部署</li><li>BSD许可证</li></ol><p>–32核64G，可支持千万并发</p><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>（1）Nginx二进制可执行文件<br>（2）Nginx。conf配置文件<br>（3）access.log访问日志<br>（4）error.log错误日志</p><h1 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h1><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_version.png"></p><h1 id="第三方模块框架"><a href="#第三方模块框架" class="headerlink" title="第三方模块框架"></a>第三方模块框架</h1><p>OpenResty</p><h1 id="编译nginx"><a href="#编译nginx" class="headerlink" title="编译nginx"></a>编译nginx</h1><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_config.png"></p><h1 id="下载安装nginx"><a href="#下载安装nginx" class="headerlink" title="下载安装nginx"></a>下载安装nginx</h1><ol><li><p>源码目录<br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_code_tree.png"></p></li><li><p>目录说明<br>① auto 用于编译，其中包含了四个主要目录，分别是cc(用于编译)、lib、os(对编译操作系统的判断)、types<br>② CHANGES: nginx的版本变化<br>③ CHANGES.ru: 俄罗斯版本<br>④ conf: 一些示例文件，nginx安装好后为了方便运维去配置，会把conf的示例文件拷贝到安装目录<br>⑤ configure: 该文件用于生成中间文件，执行编译前的必备动作<br>⑥ contrib: 提供2个perl脚本和vim的工具，改变配置nginx.conf的vim语法配色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r contrib/vim/* ~/.vim/</span><br></pre></td></tr></table></figure><p>⑦ man: nginx帮助文件<br>⑧ src: 源代码</p></li><li><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_configure.png"><br>&emsp;&emsp;如果不需要变动，编译时只需要指定–prefix参数即可，所有的文件会在prefix目录下建相应的文件夹<br>&emsp;&emsp;–with前缀的模块默认不加入编译<br>&emsp;&emsp;–without前缀的模块默认加入编译，执行该命令表示移除编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//安装依赖</span><br><span class="line">//解决zlib error依赖错误</span><br><span class="line">sudo apt install zlib1g-dev</span><br><span class="line"></span><br><span class="line">//解决openssl error依赖错误</span><br><span class="line">sudo apt install openssl libssl-dev</span><br><span class="line"></span><br><span class="line">//解决pcre error依赖错误</span><br><span class="line">sudo apt install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行configure，会生成中间文件在objs文件夹下，其中最重要的是ngx_modules.c，它决定了哪些模块将参与编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix &#x3D; ~&#x2F;home&#x2F;app&#x2F;nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/run_configure.png"><br>&emsp;&emsp;接下来是执行make编译，目标文件在objs目录“nginx”，c编译的中间文件在src目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_target.png"><br>&emsp;&emsp;最后执行安装命令，安装在prefix执行的目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/make_install.png"></p></li></ol><h1 id="nginx命令行"><a href="#nginx命令行" class="headerlink" title="nginx命令行"></a>nginx命令行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用指定配置文件 -c</span><br><span class="line">&#x2F;&#x2F;使用配置指令 -g</span><br><span class="line">&#x2F;&#x2F;指定运行目录 -p</span><br><span class="line">&#x2F;&#x2F;发送信号 -s</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;stop：立即停止服务    (kill -TERM)</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;quit：优雅的停止服务  (kill -QUIT)</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;reload：重载配置文件  (kill -SIGHUP)</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;reopen：重新开始记录日志文件 (kill -USR1)</span><br><span class="line">&#x2F;&#x2F;测试配置文件是否有语法错误 -t -T</span><br><span class="line">&#x2F;&#x2F;打印nginx的版本信息、编译信息：-v -V</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改配置后，直接nginx -s reload即可，会自动加载新的配置，在这个过程中，会重新启动一个worker进行，并将之前的worker进程优雅的退出</p><h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>&emsp;&emsp;优雅的关闭只针对http协议层<br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_quit.png"></p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_hot_flow.png"><br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_hot2.png"></p><ol><li>部署最新版本的nginx，只需替换nginx二进制文件，首先用ps -ef | grep nginx，观察进程的状态。（注意在编译新版本的nginx时，不需要执行make install命令，否则会覆盖之前的配置文件）<br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_hot.png"></li><li>然后将安装目录下sbin/nginx，修改为nginx.old<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx nginx.old</span><br></pre></td></tr></table></figure></li><li>然后将其他版本的nginx移到该目录下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ..&#x2F;openresty&#x2F;nginx&#x2F;sbin&#x2F;nginx .&#x2F;</span><br></pre></td></tr></table></figure></li><li>然后像nginx发送信号(kill -USR2 79637)，其会启动新版本nginx进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 79637</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_new.png"></li><li>然后向老的nginx进程发送一个信号(kill -WINCH 79637)，让其优雅的关闭work进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 79637</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_close_old.png"></li><li>在这之后可以看到老版本的nginx的worker进程已经关闭，还剩下master进程，master进程是为了防止新部署的版本出现问题，可以做版本回退的作用<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2></li><li>首先通过信号，kill -HUP 79637重新拉起旧版本的master进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP 79637</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_reload.png"></li><li>然后像新版本的nginx，发送kill -WINCH 112586信号使其优雅的关闭worker进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 112586</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_kill_woker.png"></li><li>最后关闭新版本的nginx master进程即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 112586</span><br></pre></td></tr></table></figure><h2 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h2></li><li>首先到log目录下，将之前日志转移到另一个文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv access.log pre_access.log</span><br></pre></td></tr></table></figure></li><li>然后在nginx目录下，执行reopen命令即可生成新的日志文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reopen</span><br></pre></td></tr></table></figure><h1 id="Nginx信号"><a href="#Nginx信号" class="headerlink" title="Nginx信号"></a>Nginx信号</h1><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_signal.png"><br>&emsp;&emsp;其中master进程会检测worker进程，当worker异常终止时，master进程会接收到一个CHLD信号。然后master进程会重新将worker进程拉起。<h1 id="reload流程"><a href="#reload流程" class="headerlink" title="reload流程"></a>reload流程</h1><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_reload_flow.png"><br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_reload_flow2.png"><br>（注意配置worker_shutdown_timeout）</li></ol><h1 id="使用Goaccess分析日志"><a href="#使用Goaccess分析日志" class="headerlink" title="使用Goaccess分析日志"></a>使用Goaccess分析日志</h1><ol><li>使用apt安装goaccess<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install goaccess</span><br></pre></td></tr></table></figure>然后执行一下命令即可。-o 分析日志网页的生成路径，其余参数查看官网帮助文档，其中注意在nginx的日志格式变化的情况下，需要修改–log-foramt参数对应的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goaccess pre_access.log -o ..&#x2F;html&#x2F;report.html --real-time-html --time-format&#x3D;&#39;%H:%M:%S&#39; --date-format&#x3D;&#39;%d&#x2F;%b&#x2F;%Y&#39; --log-format&#x3D;COMBINED</span><br></pre></td></tr></table></figure><h1 id="Nginx模块数据结构"><a href="#Nginx模块数据结构" class="headerlink" title="Nginx模块数据结构"></a>Nginx模块数据结构</h1><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_module.png"><br>&emsp;&emsp;其中ngx_module_t中的type字段定义了nginx模块的类型<br><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_module_class.png"></li></ol><h1 id="共享内存使用模块"><a href="#共享内存使用模块" class="headerlink" title="共享内存使用模块"></a>共享内存使用模块</h1><p><img src="https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/nginx_shared_memory.png"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://time.geekbang.org/">极客时间Nginx核心知识100讲</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;基础架构&quot;&gt;&lt;a href=&quot;#基础架构&quot; class=&quot;headerlink&quot; title=&quot;基础架构&quot;&gt;&lt;/a&gt;基础架构&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;img src=&quot;https://cdn.jsdelivr.n</summary>
      
    
    
    
    <category term="Nginx" scheme="https://lookupman.cn/categories/Nginx/"/>
    
    
    <category term="成长" scheme="https://lookupman.cn/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++包管理工具vcpkg的使用</title>
    <link href="https://lookupman.cn/2020/06/08/C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7vcpkg%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lookupman.cn/2020/06/08/C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7vcpkg%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-08T10:39:40.000Z</published>
    <updated>2020-06-08T20:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近在使用c++时，发现编译第三方库真的烦，同时还要在vs的设置中引入包含目录、库目录，操作起来十分繁琐。之后github上找到了vcpkg这个微软开发的包管理工具，用起来挺顺手的，就是下载包的时候，由于包服务器在外网，很多时候会安装失败，这是一个苦恼的问题。最近，在一片博客看到有大佬搭建国内个人镜像，没有梯子的，可以去<a href="https://blog.csdn.net/jackboos/article/details/105026109">了解一下</a>。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;安装很简单，可以参考github提供的<a href="https://github.com/Microsoft/vcpkg">README.md</a>。</p><ol><li>首先第一步从<u><a href="https://github.com/Microsoft/vcpkg">vcpkg仓库</a></u>把代码clone下来：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone git@github.com:microsoft&#x2F;vcpkg.git</span><br><span class="line">&gt; cd vcpkg</span><br></pre></td></tr></table></figure></li><li>然后第二步，使用命令编译vcpkg<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; .\bootstrap-vcpkg.bat   &#x2F;&#x2F;windows下</span><br><span class="line">&gt; .&#x2F;bootstrap-vcpkg.sh    &#x2F;&#x2F;Linux下</span><br></pre></td></tr></table></figure></li><li>第三步，为了方便操作，可以将目录下生成的vcpkg可执行文件，加入到系统的环境变量</li><li>第四步，为全局配置vcpkg<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; vcpkg integrate install</span><br></pre></td></tr></table></figure>&emsp;&emsp;在这一步之后，在windows下，VS中，可以直接在头部引入安装的库使用，不需要其他包含库目录等操作，十分方便。<br>&emsp;&emsp;对于不使用vs的情况，vcpkg可以在cmake中使用，通过编译参数-DCMAKE_TOOLCHAIN_FILE = [vcpkg root]\scripts\buildsystems\vcpkg.cmake，进行配置，实例如下：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(ManagerServer)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#G:/c++ Depende/vcpkg, 是我的vcpkg的根目录，在使用的时候需要更换为自己的</span></span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;</span> CACHE PATH <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="variable">$&#123;VCPKG_ROOT&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这个是查找sqlite3库的操作， 安装sqlite3的操作，请看文章的下一部分</span></span><br><span class="line"><span class="keyword">find_package</span>(sqlite3 CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. sourceList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源代码添加到此项目的可执行文件。</span></span><br><span class="line"><span class="keyword">add_executable</span> (ManagerServer <span class="variable">$&#123;sourceList&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行sqlite3库的链接</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ManagerServer PRIVATE sqlite3)</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>&emsp;&emsp;接下来是关于vcpkg的使用，本文以官方文档描述的安装和使用sqlite3的例子来介绍。</p><ol><li><p>通过search参数来查找提供的第三方包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; vcpkg search sqlite3</span><br><span class="line">dlib[sqlite3]                         sqlite3 support <span class="keyword">for</span> dlib</span><br><span class="line">soci[sqlite3]                         Build sqlite3 backend</span><br><span class="line">sqlite3              <span class="number">3</span>.<span class="number">32</span>.<span class="number">0</span>-<span class="number">0</span>         SQLite is a software library that implements a self-contained, serverless, zer...</span><br><span class="line">sqlite3[tool]                         sqlite3 executable</span><br><span class="line">sqlitecpp            <span class="number">3</span>.<span class="number">0</span>.<span class="number">0</span>            SQLiteC++ (SQLiteCpp) is a smart and easy to use C++ SQLite3 wrapper.</span><br><span class="line">sqlpp11-connector... <span class="number">0</span>.<span class="number">29</span>-<span class="number">2</span>           A C++ wrapper <span class="keyword">for</span> sqlite3 meant to be used <span class="keyword">in</span> combination with sqlpp11.</span><br></pre></td></tr></table></figure></li><li><p>通过install命令来安装包<br>&emsp;&emsp;在安装包之前，需要查看本机的VS环境是否安装的English的语言包，否则，会出现警告和报错的问题。接下来，是使用install安装第三方包，示例的环境是windows10。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; vcpkg install sqlite3</span><br><span class="line">Computing installation plan...</span><br><span class="line">The following packages will be built and installed:</span><br><span class="line">    sqlite3[core]:x86-windows</span><br><span class="line">Starting package <span class="number">1</span>/<span class="number">1</span>: sqlite3:x86-windows</span><br><span class="line">Building package sqlite3[core]:x86-windows...</span><br><span class="line">-- Using cached G:/C++ Depende/vcpkg/downloads/sqlite-amalgamation-<span class="number">3320000</span>.zip</span><br><span class="line">-- Using source <span class="built_in">at</span> G:/C++ Depende/vcpkg/buildtrees/sqlite3/src/<span class="number">3320000</span>-f17e2f22e8</span><br><span class="line">-- Configuring x86-windows</span><br><span class="line">-- Building x86-windows-dbg</span><br><span class="line">-- Building x86-windows-rel</span><br><span class="line">-- Performing post-build validation</span><br><span class="line">-- Performing post-build validation done</span><br><span class="line">Building package sqlite3[core]:x86-windows... done</span><br><span class="line">Installing package sqlite3[core]:x86-windows...</span><br><span class="line">Installing package sqlite3[core]:x86-windows... done</span><br><span class="line">Elapsed <span class="built_in">time</span> <span class="keyword">for</span> package sqlite3:x86-windows: <span class="number">11</span>.<span class="number">25</span> s</span><br><span class="line"></span><br><span class="line">Total elapsed <span class="built_in">time</span>: <span class="number">11</span>.<span class="number">25</span> s</span><br><span class="line"></span><br><span class="line">The package sqlite3:x86-windows provides CMake targets:</span><br><span class="line"></span><br><span class="line">    find_package(sqlite3 CONFIG REQUIRED)</span><br><span class="line">    target_link_libraries(main PRIVATE sqlite3)</span><br><span class="line"></span><br><span class="line">//在windows下命令默认编译的是x86的包，可以通过&quot;:&quot;指定，比如：</span><br><span class="line">&gt; vcpkg install sqlite3:x64-windows</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在完成安装后，可以看出命令行输出了，在camke中的使用语句，将其写入CMakeLists.txt就可以了，特别要注意target_link_libraries(main PRIVATE sqlite3)add_executable()后面。</p></li><li><p>利用list参数，查看已经编译安装的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; vcpkg list</span><br><span class="line">sqlite3:x64-windows                                3.32.0-0         SQLite is a software library that implements a s...</span><br><span class="line">sqlite3:x86-windows                                3.32.0-0         SQLite is a software library that implements a s...</span><br></pre></td></tr></table></figure></li><li><p>利用remove参数，卸载已经编译安装的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; vcpkg remove [package_name]</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><ol><li>main.cpp文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sqlite3 *pdb = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = sqlite3_open(<span class="string">&quot;test.db&quot;</span>, &amp;pdb);</span><br><span class="line">  <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sqlite_open error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sqlite3_stmt *pStmt;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *sql =</span><br><span class="line">      <span class="string">&quot;create table Student(&quot;</span></span><br><span class="line">      <span class="string">&quot;t_id, integer primary key, &quot;</span></span><br><span class="line">      <span class="string">&quot;t_name varchar(15), t_age integer)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *errMsg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  result = sqlite3_exec(pdb, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errMsg);</span><br><span class="line">  <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create table student failed!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error conde %d \t error message:%s\n&quot;</span>, result, errMsg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;create table success!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>CMakeLists.txt文件<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(ManagerServer)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;</span> CACHE PATH <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="variable">$&#123;VCPKG_ROOT&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(sqlite3 CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. sourceList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将源代码添加到此项目的可执行文件。</span></span><br><span class="line"><span class="keyword">add_executable</span> (ManagerServer <span class="variable">$&#123;sourceList&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ManagerServer PRIVATE sqlite3)</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://blog.csdn.net/jackboos/article/details/105026109">vcpkg国内镜像使用方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近在使用c++时，发现编译第三方库真的烦，同时还要在vs的设置中引入包含目录、</summary>
      
    
    
    
    <category term="C++" scheme="https://lookupman.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://lookupman.cn/tags/C/"/>
    
    <category term="包管理工具" scheme="https://lookupman.cn/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://lookupman.cn/2020/06/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://lookupman.cn/2020/06/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2020-06-07T03:07:59.000Z</published>
    <updated>2020-06-07T14:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="要开始写博客了，不然很多东西，好久没用了就忘了"><a href="#要开始写博客了，不然很多东西，好久没用了就忘了" class="headerlink" title="要开始写博客了，不然很多东西，好久没用了就忘了"></a>要开始写博客了，不然很多东西，好久没用了就忘了</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;要开始写博客了，不然很多东西，好久没用了就忘了&quot;&gt;&lt;a href=&quot;#要开始写博客了，不然很多东西，好久没用了就忘了&quot; class=&quot;headerlink&quot; title=&quot;要开始写博客了，不然很多东西，好久没用了就忘了&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="生活" scheme="https://lookupman.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="成长" scheme="https://lookupman.cn/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
</feed>
