{"meta":{"title":"lookupman的博客","subtitle":"","description":"","author":"lookupman","url":"https://lookupman.cn","root":"/"},"pages":[{"title":"C++","date":"2020-06-08T10:40:24.000Z","updated":"2020-06-08T10:41:02.802Z","comments":true,"path":"C/index.html","permalink":"https://lookupman.cn/C/index.html","excerpt":"","text":""},{"title":"C++","date":"2020-06-08T10:41:08.000Z","updated":"2020-06-08T10:41:30.410Z","comments":true,"path":"C/index-1.html","permalink":"https://lookupman.cn/C/index-1.html","excerpt":"","text":""},{"title":"Nginx","date":"2020-10-18T09:26:46.000Z","updated":"2020-10-18T09:27:02.203Z","comments":true,"path":"Nginx/index.html","permalink":"https://lookupman.cn/Nginx/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-09T10:52:09.000Z","updated":"2020-06-08T13:56:53.518Z","comments":true,"path":"friend/index.html","permalink":"https://lookupman.cn/friend/index.html","excerpt":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://cdn.jsdelivr.net/gh/dream-kzx/blog_image/img/avatar.jpg 网站名称：lookupman的博客 网站地址：https://lookupman.cn 网站简介：后端开发、记录成长、分享生活 加载中，稍等几秒..."},{"title":"关于","date":"2020-11-08T12:14:24.296Z","updated":"2020-11-08T12:14:24.296Z","comments":false,"path":"about/index.html","permalink":"https://lookupman.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"","date":"2019-07-29T08:28:26.000Z","updated":"2020-06-07T09:20:59.847Z","comments":true,"path":"album/index.html","permalink":"https://lookupman.cn/album/index.html","excerpt":"","text":"图片搜集于互联网，侵权请留言，马上处理😊。"},{"title":"","date":"2018-11-11T00:24:49.000Z","updated":"2020-06-07T10:42:51.523Z","comments":true,"path":"message/index.html","permalink":"https://lookupman.cn/message/index.html","excerpt":"","text":"畅所欲言，有留必应"},{"title":"","date":"2019-07-30T01:33:48.000Z","updated":"2020-06-07T08:24:31.269Z","comments":true,"path":"media/index.html","permalink":"https://lookupman.cn/media/index.html","excerpt":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多"},{"title":"音乐歌单收藏","date":"2019-07-30T02:43:45.000Z","updated":"2020-06-06T06:15:46.411Z","comments":true,"path":"music/index.html","permalink":"https://lookupman.cn/music/index.html","excerpt":"","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！"},{"title":"包管理工具","date":"2020-06-08T10:43:10.000Z","updated":"2020-06-08T10:43:21.089Z","comments":true,"path":"包管理工具/index.html","permalink":"https://lookupman.cn/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-25T06:49:08.000Z","updated":"2020-06-07T14:41:45.927Z","comments":false,"path":"self-talking/index.html","permalink":"https://lookupman.cn/self-talking/index.html","excerpt":"","text":"日常动态和感想 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46f4ecc2bac37d9774b3', clientSecret: '2e3bfb7189e25c4ab26daaa672dc5fe3c76f3c37', id: '8888', repo: 'everyday_issues', owner: 'dream-kzx', admin: \"dream-kzx\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });"},{"title":"生活","date":"2020-06-07T03:39:32.000Z","updated":"2020-06-07T07:05:08.288Z","comments":true,"path":"生活/index.html","permalink":"https://lookupman.cn/%E7%94%9F%E6%B4%BB/index.html","excerpt":"","text":""},{"title":"成长","date":"2020-06-07T06:59:41.000Z","updated":"2020-10-18T09:27:05.294Z","comments":true,"path":"成长/index.html","permalink":"https://lookupman.cn/%E6%88%90%E9%95%BF/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-08T09:55:18.325Z","updated":"2020-11-08T09:55:18.325Z","comments":false,"path":"tags/index.html","permalink":"https://lookupman.cn/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-11-08T09:55:18.319Z","updated":"2020-11-08T09:55:18.319Z","comments":false,"path":"/404.html","permalink":"https://lookupman.cn/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-11-08T09:55:18.322Z","updated":"2020-11-08T09:55:18.322Z","comments":false,"path":"books/index.html","permalink":"https://lookupman.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-08T09:55:18.323Z","updated":"2020-11-08T09:55:18.323Z","comments":false,"path":"categories/index.html","permalink":"https://lookupman.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-11-08T11:56:37.901Z","updated":"2020-11-08T11:56:37.901Z","comments":true,"path":"links/index.html","permalink":"https://lookupman.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-11-08T09:55:18.324Z","updated":"2020-11-08T09:55:18.324Z","comments":false,"path":"repository/index.html","permalink":"https://lookupman.cn/repository/index.html","excerpt":"","text":""},{"title":"Golang","date":"2020-11-08T13:09:23.000Z","updated":"2020-11-08T13:23:39.401Z","comments":true,"path":"Golang/index.html","permalink":"https://lookupman.cn/Golang/index.html","excerpt":"","text":""}],"posts":[{"title":"gorm学习记录","slug":"gorm学习记录","date":"2020-11-08T08:29:08.000Z","updated":"2020-11-08T13:26:32.073Z","comments":true,"path":"2020/11/08/gorm学习记录/","link":"","permalink":"https://lookupman.cn/2020/11/08/gorm%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"参考文章:参考链接","categories":[{"name":"Golang","slug":"Golang","permalink":"https://lookupman.cn/categories/Golang/"}],"tags":[]},{"title":"ioutil一些方便的操作函数集","slug":"ioutil一些方便的操作函数集","date":"2020-10-26T14:31:41.000Z","updated":"2020-11-08T13:24:03.759Z","comments":true,"path":"2020/10/26/ioutil一些方便的操作函数集/","link":"","permalink":"https://lookupman.cn/2020/10/26/ioutil%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%9B%86/","excerpt":"","text":"1. NopCloser函数&emsp;&emsp;该函数是将一个io.Reader接口包装成一个io.ReadCloser接口，其中包装生成的Close方法什么也不操作。可以在需要将io.Reader传入io.ReadCloser参数的函数的情况下使用。 1234567type nopCloser struct &#123; io.Reader&#125;func(nopCloser) Close() error &#123; return nil&#125; 2. ReadAll函数&emsp;&emsp;很多时候，我们需要一次性读取 io.Reader 中的数据，通过上一节的讲解，我们知道有很多种实现方式。考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。 1func ReadAll(r io.Reader) ([]byte, error) &emsp;&emsp;阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。该函数成功调用后会返回 err == nil 而不是 err == EOF。(成功读取完毕应该为 err == io.EOF，这里返回 nil 由于该函数成功期望 err == io.EOF，符合无错误不处理的理念) 参考文章:参考链接","categories":[{"name":"Golang","slug":"Golang","permalink":"https://lookupman.cn/categories/Golang/"}],"tags":[]},{"title":"Golang基本输入输出(io包接口)","slug":"Golang基本输入输出(io包接口)","date":"2020-10-25T08:22:58.000Z","updated":"2020-11-08T13:23:53.327Z","comments":true,"path":"2020/10/25/Golang基本输入输出(io包接口)/","link":"","permalink":"https://lookupman.cn/2020/10/25/Golang%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA(io%E5%8C%85%E6%8E%A5%E5%8F%A3)/","excerpt":"&emsp;&emsp;在本章的所有的io接口时，有一个特点，在读取或写入的n=len(p)时，返回的接口err=nil或者err=EOF；当n&lt;len(p)时，需要返回err解释原因。","text":"&emsp;&emsp;在本章的所有的io接口时，有一个特点，在读取或写入的n=len(p)时，返回的接口err=nil或者err=EOF；当n&lt;len(p)时，需要返回err解释原因。 1. Reader接口&emsp;&emsp;在官方io包中定义了如下接口，只要实现了Read方法，就是将其传递为io.Reader类型的参数 123type Reader interface &#123; Read(p []byte)(n int, err error)&#125; 2. Writer接口&emsp;&emsp;在官方的io包中定义里如下接口，只要实现了Write方法，也就是实现了Writer接口 123type Writer interface&#123; Write(p []byte)(n int, err error)&#125; 3. 实现Reader和Writer接口的类型os.File同时实现了io.Reader和io.Writer接口strings.Reader实现了io.Reader接口bufio.Reader/Writer分别实现了io.Reader和io.Writer接口bytes.Buffer同时实现了io.Reader和io.Writer接口bytes.Reader实现了io.Reader接口compress/gzip.StreamReader/StreamWriter分别实现了io.Reader和io.Writer接口encoding/csv.Reader/Writer分别实现了io.Reader和io.Writer接口net/conn分别实现了io.Reader和io.Writer接口(Conn接口定义了Read/Write) 4. ReaderAt接口&emsp;&emsp;该接口是从源输入的偏移量off处读取len(p)个字节到p中。 123type ReaderAt struct &#123; ReadAt(p []byte, off int64)(n int, err error)&#125; 5. WriterAt接口&emsp;&emsp;该接口是在源输出的偏移量off处写入len(p)个字节。 123type WriterAt struct &#123; WriteAt(p []byte, off int64)(n int, err error)&#125; 6. ReaderFrom接口&emsp;&emsp;ReadFrom从r中读取数据，直到EOF或发生错误。 123type ReaderFrom struct &#123; ReadFrom(r Reader)(n int64, err error)&#125; 使用示例 123456789file, err := os.Open(&quot;writerAt.txt&quot;)if err != nil&#123; painc(err)&#125;defer file.Close()writer := bufio.NewWriter(os.Stdout)writer.ReadFrom(file)writer.Flush() 7. WriterTo接口&emsp;emsp;WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。 123type WriterTo struct&#123; WriteTo(w Writer)(n int, err error)&#125; 8. Seeker接口&emsp;&emsp;Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。 123456789const( SeekStart = 0 SeekCurrent = 1 SeekEnd = 2)type Seeker struct&#123; Seek(offset int64, whence int)(ret int64, err error)&#125; 9. Closer接口接口定义如下： 123type Closer interface&#123; Close() error&#125; 10. ByteReader和ByteWriter接口&emsp;&emsp;这个两个接口用于读/写一个字节 1234567type ByteReader interface&#123; ReadByte()(c byte, err error)&#125;type ByteWriter interface&#123; WriteByte(c byte) error&#125; 在标准库中，有如下类型实现了 io.ByteReader 或 io.ByteWriter:bufio.Reader/Writer 分别实现了io.ByteReader 和 io.ByteWriterbytes.Buffer 同时实现了 io.ByteReader 和 io.ByteWriterbytes.Reader 实现了 io.ByteReaderstrings.Reader 实现了 io.ByteReader 11. ByteScanner、RuneReader和RuneScanner接口&emsp;&emsp;UnreadByte 方法的意思是：将上一次 ReadByte 的字节还原，使得再次调用 ReadByte 返回的结果和上一次调用相同，也就是说，UnreadByte 是重置上一次的 ReadByte。注意，UnreadByte 调用之前必须调用了 ReadByte，且不能连续调用 UnreadByte。 123456789101112131415type ByteScanner interface &#123; ByteReader UnreadByte() error&#125;//RuneReader和ByteReader类似type RuneReader interface &#123; ReadRune()(r rune, size int, err error)&#125;//RuneScanner和ByteScanner类似type RuneScanner interface &#123; RuneReader UnreadRune() error&#125; 12. SectionReader接口&emsp;&emsp;NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。 12345678910type SectionReader struct &#123; r ReaderAt base int64 //NewSectionReader会将base设置为off off int64 //从r中off偏移处开始读取数据 limit int64 //limit-off = SectionReader流的长度&#125;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader &#123;&#125; LimitedReader接口&emsp;&emsp;从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。也就是说，最多只能返回 N 字节数据。1234type LimitedReader struct &#123; R Reader //underlying reader,最终的读取通过R.Read完成 N int64 //max bytes remaining&#125; &emsp;&emsp;使用示例1234567891011content := &quot;This is LimitReader Example&quot;reader := strings.NewReader(content)limitReader := &amp;io.LimitedReader&#123;R:reader, N:8&#125;for limitReader.N &gt; 0&#123; tmp := make([]byte, 2) limitReader.Read(tmp) fmt.Printf(&quot;%s&quot;, tmp)&#125;//输出： This Is//从结果看一看出最多只能读取N个字符 14. PipeReader和PipeWriter接口&emsp;&emsp;关于 PipeReader.Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端被关闭。如果写入端关闭时带有 error（即调用 CloseWithError 关闭），该Read返回的 err 就是写入端传递的error；否则 err 为 EOF。&emsp;&emsp;关于 PipeWriter.Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端被关闭。如果读取端关闭时带有 error（即调用 CloseWithError 关闭），该Write返回的 err 就是读取端传递的error；否则 err 为 ErrClosedPipe。 1234567type PipeReader struct &#123; p *pipe&#125;type PipeWriter struct&#123; p *pipe&#125; &emsp;&emsp;使用示例如下 123456789101112131415161718192021222324252627282930313233func main() &#123; pipeReader, pipeWriter := io.Pipe() go PipeWrite(pipeWriter) go PipeRead(pipeReader) time.Sleep(30 * time.Second)&#125;func PipeWrite(writer *io.PipeWriter)&#123; data := []byte(&quot;hello world!&quot;) for i := 0; i &lt; 3; i++&#123; n, err := writer.Write(data) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(&quot;写入字节%d\\n&quot;, n) &#125; writer.CloseWithError(errors.New(&quot;写入段已经关闭！&quot;))&#125;func PipeRead(reader *io.PipeReader)&#123; buf := make([]byte, 128) for&#123; fmt.Println(&quot;接口开始测试....&quot;) time.Sleep(5*time.Second) n, err := reader.Read(buf) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(&quot;收到%d个字节，数据为：%s\\n&quot;, n, buf) &#125;&#125; 15. Copy和CopyN函数&emsp;&emsp;Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。 1func Copy(dst Writer, src Reader)(written int64, err error)&#123;&#125; &emsp;&emsp;CopyN 将 n 个字节(或到一个error)从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当err == nil时,written == n 。&emsp;&emsp;若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。 1func CopyN(dst Writer, src Reader, n int64)(written int64, err error)&#123;&#125; 16. ReadAtLeast和ReadFull函数&emsp;&emsp;ReadAtLeast 将 r 读取到 buf 中，直到读了最少 min 个字节为止。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个EOF 发生在读取了少于min个字节之后，ReadAtLeast就会返回ErrUnexpectedEOF。若 min 大于 buf 的长度，ReadAtLeast 就会返回ErrShortBuffer。对于返回值，当且仅当 err == nil 时，才有 n &gt;= min。 1func ReadAtLeast(r Reader, buf []byte, min int)(n int, err error)&#123;&#125; &emsp;&emsp;ReadFull 精确地从 r 中将 len(buf) 个字节读取到 buf 中。它返回复制的字节数，如果读取的字节较少，还会返回一个错误。若没有读取到字节，错误就只是 EOF。如果一个 EOF 发生在读取了一些但不是所有的字节后，ReadFull 就会返回 ErrUnexpectedEOF。对于返回值，当且仅当 err == nil 时，才有 n == len(buf)。 1func ReadFull(r Reader, buf []byte)(n int, err error) 17. WriteString函数&emsp;&emsp;WriteString 将s的内容写入w中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。 1func WriteString(w writer, s string)(n int, err error) 18. MultiReader和MultiWriter函数12345678910type multiReader struct &#123; readers []Reader&#125;type multiWriter struct &#123; writers []Writer&#125;func MultiReader(readers ...Reader) Readerfunc MultiWriter(writers ...Writer) Writer 使用示例如下： 1234567891011121314151617readers := []io.Reader&#123; strings.NewReader(&quot;from strings reader&quot;), bytes.NewBufferString(&quot;from bytes buffer&quot;),&#125;reader := io.MultiReader(readers...)data := make([]byte, 0, 128)buf := make([]byte, 10)for n, err := reader.Read(buf); err != io.EOF ; n, err = reader.Read(buf)&#123; if err != nil&#123; panic(err) &#125; data = append(data,buf[:n]...)&#125;fmt.Printf(&quot;%s\\n&quot;, data)//输出//from strings readerfrom bytes buffer 12345678910111213file, err := os.Create(&quot;tmp.txt&quot;)if err != nil &#123; panic(err)&#125;defer file.Close()writers := []io.Writer&#123; file, os.Stdout,&#125;writer := io.MultiWriter(writers...)writer.Write([]byte(&quot;Hello World!&quot;))//输出：控制台和文件同时输出Hello World! 参考文章:《Go语言标准库》","categories":[{"name":"Golang","slug":"Golang","permalink":"https://lookupman.cn/categories/Golang/"}],"tags":[]},{"title":"nginx学习记录","slug":"nginx学习记录","date":"2020-10-18T09:23:54.000Z","updated":"2020-10-18T09:23:54.000Z","comments":true,"path":"2020/10/18/nginx学习记录/","link":"","permalink":"https://lookupman.cn/2020/10/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"基础架构&emsp;&emsp; 1.请求流程 优点 高并发，高性能 可扩展性良好 高可靠性 热部署 BSD许可证 –32核64G，可支持千万并发 组成（1）Nginx二进制可执行文件（2）Nginx。conf配置文件（3）access.log访问日志（4）error.log错误日志 历史版本 第三方模块框架OpenResty 编译nginx 下载安装nginx 源码目录 目录说明① auto 用于编译，其中包含了四个主要目录，分别是cc(用于编译)、lib、os(对编译操作系统的判断)、types② CHANGES: nginx的版本变化③ CHANGES.ru: 俄罗斯版本④ conf: 一些示例文件，nginx安装好后为了方便运维去配置，会把conf的示例文件拷贝到安装目录⑤ configure: 该文件用于生成中间文件，执行编译前的必备动作⑥ contrib: 提供2个perl脚本和vim的工具，改变配置nginx.conf的vim语法配色 1cp -r contrib/vim/* ~/.vim/ ⑦ man: nginx帮助文件⑧ src: 源代码 编译 1.&#x2F;configure --help | more &emsp;&emsp;如果不需要变动，编译时只需要指定–prefix参数即可，所有的文件会在prefix目录下建相应的文件夹&emsp;&emsp;–with前缀的模块默认不加入编译&emsp;&emsp;–without前缀的模块默认加入编译，执行该命令表示移除编译 123456789//安装依赖//解决zlib error依赖错误sudo apt install zlib1g-dev//解决openssl error依赖错误sudo apt install openssl libssl-dev//解决pcre error依赖错误sudo apt install libpcre3 libpcre3-dev &emsp;&emsp;执行configure，会生成中间文件在objs文件夹下，其中最重要的是ngx_modules.c，它决定了哪些模块将参与编译 1.&#x2F;configure --prefix &#x3D; ~&#x2F;home&#x2F;app&#x2F;nginx &emsp;&emsp;接下来是执行make编译，目标文件在objs目录“nginx”，c编译的中间文件在src目录 1make &emsp;&emsp;最后执行安装命令，安装在prefix执行的目录中 1make install nginx命令行12345678910&#x2F;&#x2F;使用指定配置文件 -c&#x2F;&#x2F;使用配置指令 -g&#x2F;&#x2F;指定运行目录 -p&#x2F;&#x2F;发送信号 -s&#x2F;&#x2F;&#x2F;&#x2F;stop：立即停止服务 (kill -TERM)&#x2F;&#x2F;&#x2F;&#x2F;quit：优雅的停止服务 (kill -QUIT)&#x2F;&#x2F;&#x2F;&#x2F;reload：重载配置文件 (kill -SIGHUP)&#x2F;&#x2F;&#x2F;&#x2F;reopen：重新开始记录日志文件 (kill -USR1)&#x2F;&#x2F;测试配置文件是否有语法错误 -t -T&#x2F;&#x2F;打印nginx的版本信息、编译信息：-v -V &emsp;&emsp;修改配置后，直接nginx -s reload即可，会自动加载新的配置，在这个过程中，会重新启动一个worker进行，并将之前的worker进程优雅的退出 优雅关闭&emsp;&emsp;优雅的关闭只针对http协议层 热部署 部署最新版本的nginx，只需替换nginx二进制文件，首先用ps -ef | grep nginx，观察进程的状态。（注意在编译新版本的nginx时，不需要执行make install命令，否则会覆盖之前的配置文件） 然后将安装目录下sbin/nginx，修改为nginx.old1mv nginx nginx.old 然后将其他版本的nginx移到该目录下1cp ..&#x2F;openresty&#x2F;nginx&#x2F;sbin&#x2F;nginx .&#x2F; 然后像nginx发送信号(kill -USR2 79637)，其会启动新版本nginx进程1kill -USR2 79637 然后向老的nginx进程发送一个信号(kill -WINCH 79637)，让其优雅的关闭work进程1kill -WINCH 79637 在这之后可以看到老版本的nginx的worker进程已经关闭，还剩下master进程，master进程是为了防止新部署的版本出现问题，可以做版本回退的作用版本回退 首先通过信号，kill -HUP 79637重新拉起旧版本的master进程1kill -HUP 79637 然后像新版本的nginx，发送kill -WINCH 112586信号使其优雅的关闭worker进程1kill -WINCH 112586 最后关闭新版本的nginx master进程即可1kill -9 112586 日志切割 首先到log目录下，将之前日志转移到另一个文件1mv access.log pre_access.log 然后在nginx目录下，执行reopen命令即可生成新的日志文件1sudo nginx -s reopen Nginx信号&emsp;&emsp;其中master进程会检测worker进程，当worker异常终止时，master进程会接收到一个CHLD信号。然后master进程会重新将worker进程拉起。reload流程（注意配置worker_shutdown_timeout） 使用Goaccess分析日志 使用apt安装goaccess1sudo apt install goaccess 然后执行一下命令即可。-o 分析日志网页的生成路径，其余参数查看官网帮助文档，其中注意在nginx的日志格式变化的情况下，需要修改–log-foramt参数对应的值1goaccess pre_access.log -o ..&#x2F;html&#x2F;report.html --real-time-html --time-format&#x3D;&#39;%H:%M:%S&#39; --date-format&#x3D;&#39;%d&#x2F;%b&#x2F;%Y&#39; --log-format&#x3D;COMBINED Nginx模块数据结构&emsp;&emsp;其中ngx_module_t中的type字段定义了nginx模块的类型 共享内存使用模块 参考文章 极客时间Nginx核心知识100讲","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://lookupman.cn/categories/Nginx/"}],"tags":[{"name":"成长","slug":"成长","permalink":"https://lookupman.cn/tags/%E6%88%90%E9%95%BF/"}]},{"title":"C++包管理工具vcpkg的使用","slug":"C++包管理工具vcpkg的使用","date":"2020-06-08T10:39:40.000Z","updated":"2020-06-08T20:07:50.000Z","comments":true,"path":"2020/06/08/C++包管理工具vcpkg的使用/","link":"","permalink":"https://lookupman.cn/2020/06/08/C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7vcpkg%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言&emsp;&emsp;最近在使用c++时，发现编译第三方库真的烦，同时还要在vs的设置中引入包含目录、库目录，操作起来十分繁琐。之后github上找到了vcpkg这个微软开发的包管理工具，用起来挺顺手的，就是下载包的时候，由于包服务器在外网，很多时候会安装失败，这是一个苦恼的问题。最近，在一片博客看到有大佬搭建国内个人镜像，没有梯子的，可以去了解一下。 安装&emsp;&emsp;安装很简单，可以参考github提供的README.md。 首先第一步从vcpkg仓库把代码clone下来：12&gt; git clone git@github.com:microsoft&#x2F;vcpkg.git&gt; cd vcpkg 然后第二步，使用命令编译vcpkg12&gt; .\\bootstrap-vcpkg.bat &#x2F;&#x2F;windows下&gt; .&#x2F;bootstrap-vcpkg.sh &#x2F;&#x2F;Linux下 第三步，为了方便操作，可以将目录下生成的vcpkg可执行文件，加入到系统的环境变量 第四步，为全局配置vcpkg1&gt; vcpkg integrate install &emsp;&emsp;在这一步之后，在windows下，VS中，可以直接在头部引入安装的库使用，不需要其他包含库目录等操作，十分方便。&emsp;&emsp;对于不使用vs的情况，vcpkg可以在cmake中使用，通过编译参数-DCMAKE_TOOLCHAIN_FILE = [vcpkg root]\\scripts\\buildsystems\\vcpkg.cmake，进行配置，实例如下：12345678910111213141516171819cmake_minimum_required (VERSION 3.8)project(ManagerServer)set(CMAKE_CXX_STANDARD 14)#G:/c++ Depende/vcpkg, 是我的vcpkg的根目录，在使用的时候需要更换为自己的set(VCPKG_ROOT &quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot; CACHE PATH &quot;&quot;)set(CMAKE_TOOLCHAIN_FILE $&#123;VCPKG_ROOT&#125;)#这个是查找sqlite3库的操作， 安装sqlite3的操作，请看文章的下一部分find_package(sqlite3 CONFIG REQUIRED)aux_source_directory(. sourceList)# 将源代码添加到此项目的可执行文件。add_executable (ManagerServer $&#123;sourceList&#125;)#进行sqlite3库的链接target_link_libraries(ManagerServer PRIVATE sqlite3) 使用&emsp;&emsp;接下来是关于vcpkg的使用，本文以官方文档描述的安装和使用sqlite3的例子来介绍。 通过search参数来查找提供的第三方包 1234567&gt; vcpkg search sqlite3dlib[sqlite3] sqlite3 support for dlibsoci[sqlite3] Build sqlite3 backendsqlite3 3.32.0-0 SQLite is a software library that implements a self-contained, serverless, zer...sqlite3[tool] sqlite3 executablesqlitecpp 3.0.0 SQLiteC++ (SQLiteCpp) is a smart and easy to use C++ SQLite3 wrapper.sqlpp11-connector... 0.29-2 A C++ wrapper for sqlite3 meant to be used in combination with sqlpp11. 通过install命令来安装包&emsp;&emsp;在安装包之前，需要查看本机的VS环境是否安装的English的语言包，否则，会出现警告和报错的问题。接下来，是使用install安装第三方包，示例的环境是windows10。 123456789101112131415161718192021222324252627&gt; vcpkg install sqlite3Computing installation plan...The following packages will be built and installed: sqlite3[core]:x86-windowsStarting package 1/1: sqlite3:x86-windowsBuilding package sqlite3[core]:x86-windows...-- Using cached G:/C++ Depende/vcpkg/downloads/sqlite-amalgamation-3320000.zip-- Using source at G:/C++ Depende/vcpkg/buildtrees/sqlite3/src/3320000-f17e2f22e8-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Performing post-build validation-- Performing post-build validation doneBuilding package sqlite3[core]:x86-windows... doneInstalling package sqlite3[core]:x86-windows...Installing package sqlite3[core]:x86-windows... doneElapsed time for package sqlite3:x86-windows: 11.25 sTotal elapsed time: 11.25 sThe package sqlite3:x86-windows provides CMake targets: find_package(sqlite3 CONFIG REQUIRED) target_link_libraries(main PRIVATE sqlite3)//在windows下命令默认编译的是x86的包，可以通过&quot;:&quot;指定，比如：&gt; vcpkg install sqlite3:x64-windows &emsp;&emsp;在完成安装后，可以看出命令行输出了，在camke中的使用语句，将其写入CMakeLists.txt就可以了，特别要注意target_link_libraries(main PRIVATE sqlite3)add_executable()后面。 利用list参数，查看已经编译安装的包 123&gt; vcpkg listsqlite3:x64-windows 3.32.0-0 SQLite is a software library that implements a s...sqlite3:x86-windows 3.32.0-0 SQLite is a software library that implements a s... 利用remove参数，卸载已经编译安装的包 1&gt; vcpkg remove [package_name] 使用实例 main.cpp文件12345678910111213141516171819202122232425262728293031// main.cpp#include &lt;errno.h&gt;#include &lt;sqlite3.h&gt;#include &lt;stdio.h&gt;int main() &#123; sqlite3 *pdb = nullptr; int result; result = sqlite3_open(&quot;test.db&quot;, &amp;pdb); if (result != SQLITE_OK) &#123; perror(&quot;sqlite_open error!&quot;); return -1; &#125; sqlite3_stmt *pStmt; const char *sql = &quot;create table Student(&quot; &quot;t_id, integer primary key, &quot; &quot;t_name varchar(15), t_age integer)&quot;; char *errMsg = NULL; result = sqlite3_exec(pdb, sql, NULL, NULL, &amp;errMsg); if (result != SQLITE_OK) &#123; printf(&quot;create table student failed!\\n&quot;); printf(&quot;error conde %d \\t error message:%s\\n&quot;, result, errMsg); &#125; printf(&quot;create table success!\\n&quot;); return 0;&#125; CMakeLists.txt文件1234567891011121314151617#CMakeLists.txtcmake_minimum_required (VERSION 3.8)project(ManagerServer)set(CMAKE_CXX_STANDARD 14)set(VCPKG_ROOT &quot;G:/C++ Depende/vcpkg/scripts/buildsystems/vcpkg.cmake&quot; CACHE PATH &quot;&quot;)set(CMAKE_TOOLCHAIN_FILE $&#123;VCPKG_ROOT&#125;)find_package(sqlite3 CONFIG REQUIRED)aux_source_directory(. sourceList)# 将源代码添加到此项目的可执行文件。add_executable (ManagerServer $&#123;sourceList&#125;)target_link_libraries(ManagerServer PRIVATE sqlite3) 参考文章 vcpkg国内镜像使用方法","categories":[{"name":"C++","slug":"C","permalink":"https://lookupman.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://lookupman.cn/tags/C/"},{"name":"包管理工具","slug":"包管理工具","permalink":"https://lookupman.cn/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}]},{"title":"新的开始","slug":"新的开始","date":"2020-06-07T03:07:59.000Z","updated":"2020-06-07T14:07:50.000Z","comments":true,"path":"2020/06/07/新的开始/","link":"","permalink":"https://lookupman.cn/2020/06/07/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/","excerpt":"","text":"要开始写博客了，不然很多东西，好久没用了就忘了","categories":[{"name":"生活","slug":"生活","permalink":"https://lookupman.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"成长","slug":"成长","permalink":"https://lookupman.cn/tags/%E6%88%90%E9%95%BF/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://lookupman.cn/categories/Golang/"},{"name":"Nginx","slug":"Nginx","permalink":"https://lookupman.cn/categories/Nginx/"},{"name":"C++","slug":"C","permalink":"https://lookupman.cn/categories/C/"},{"name":"生活","slug":"生活","permalink":"https://lookupman.cn/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"成长","slug":"成长","permalink":"https://lookupman.cn/tags/%E6%88%90%E9%95%BF/"},{"name":"C++","slug":"C","permalink":"https://lookupman.cn/tags/C/"},{"name":"包管理工具","slug":"包管理工具","permalink":"https://lookupman.cn/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"}]}